好的，我将使用Markdown格式撰写完整的、可持续迭代的软件工程开发计划文档。我们将严格遵循软件工程流程，从需求分析到架构设计、环境配置、Cursor IDE使用说明、项目初始化、开发与测试计划、打包部署等环节，确保每个阶段有据可依、可追溯、可维护。

我会在片刻后呈现第一版开发计划文档。


# 项目概述与背景

本项目旨在开发一款**跨平台客户端应用**，用于中药多组分均化分析，前端使用 Electron 构建，后端算法逻辑（包括符号回归和蒙特卡罗模拟）使用 Python 实现。中药复方药物成分复杂多样，经典名方往往含有数十种甚至上百种化学成分，其理化性质差异大。监管机构《中药特征图谱研究技术指导原则》强调，应建立能够反映多组分信息的质量特征图谱，并鼓励在图谱分析中应用新技术。然而，**现有分析方法开发难度大**：由于成分种类繁多且性质各异，多成分含量测定和指纹图谱等质量控制方案相比单一成分分析面临更大挑战。因此，需要开发高效的软件工具，通过先进算法实现多组分数据的均化处理和分析，以辅助科研人员和质量工程师进行系统研究。项目选用 Electron 作为前端框架，可在 Windows、Linux 等环境下提供一致的用户界面；后端利用 Python 强大的数据科学生态（如 NumPy、SciPy、SymPy、PySR 等）来实现符号回归、随机模拟等算法模块，满足数据建模和仿真需求。

# 需求分析

## 功能性需求

* **数据输入与管理**：用户可以导入实验数据（如 CSV、Excel、JSON 等格式），支持批量或单个数据文件加载。支持管理和保存常用的数据集、实验条件等。
* **分析算法调用**：提供多组分分析算法的配置与执行，包括符号回归模型搜索、多组分反应动力学建模以及蒙特卡罗不确定性模拟等。用户可选择算法类型、设置参数（如进化代数、随机种子、采样次数等），执行计算并获取结果。
* **结果可视化**：将分析结果以图表方式展现，如曲线拟合图、分布直方图、散点图、热力图等。图表支持交互，如缩放、悬浮提示、导出图片等功能。
* **报告生成与导出**：允许用户生成分析报告（如 PDF 或 Markdown 格式），包含分析摘要、关键图表和结论。支持导出原始数据和计算结果（CSV/JSON）以便后续处理。
* **项目和用户管理**（可选）：支持多人协作和分角色操作，例如管理员管理数据权限，分析师保存项目版本，用户提交问题反馈等。

## 非功能性需求

* **跨平台支持**：应用应支持主流桌面操作系统（Windows、Linux、MacOS），保证界面和功能一致。Electron 本身打包后占用资源较多，但可以接受。
* **性能和响应性**：后端算法可能耗时较长，应采用异步计算或后台线程处理，避免界面阻塞。对于大型数据集或蒙特卡罗模拟，需提示进度并保证应用稳定运行。
* **可扩展性与维护性**：采用模块化设计，算法、界面和数据层分离，代码应便于维护。使用版本控制（Git/GitHub）和依赖管理工具（如 Poetry）确保环境可复现。
* **安全性**：尽管是本地应用，但前端与后端通信需注意防注入和异常处理。若支持在线更新或插件，需考虑签名和校验机制。
* **国际化与本地化**：界面语言可支持中英（主要为中文），方便不同用户使用环境。时间和数字格式根据用户系统区域自动调整。
* **可用性**：界面简洁友好，引导性强。对科研人员来说，提供数据导入模板和范例，图形操作直观，降低上手成本。

## 用户角色与用户故事

* **数据分析师/科研人员**：主要使用者，负责导入实验数据、配置分析算法并解读结果。故事示例：*“作为一名药物分析研究人员，我希望通过导入LC-MS色谱数据，自动构建中药多组分回归模型，以快速找出关键成分的含量规律。”*
* **系统维护者/开发人员**：负责软件安装、环境配置和持续开发。故事示例：*“作为开发人员，我希望使用 Git 进行版本控制并在 GitHub 上协同开发；通过 Cursor IDE 提升算法编写效率并确保代码可维护。”*
* **产品经理/项目负责人**：跟踪项目进度，协调资源。故事示例：*“作为项目负责人，我希望项目按迭代计划完成，从原型到 MVP，再到最终版本，能持续集成和交付成果。”*

# 技术选型

## 前端

选用 **Electron** 作为前端技术栈。Electron 将 Chromium + Node.js 嵌入可执行文件中，使开发者可以使用 HTML/CSS/JavaScript 构建跨平台桌面应用。这种方案让团队可以利用已有的 Web 技术栈，无需编写原生代码，从而节省开发成本。Electron 在实际项目中已有成功案例（如 VS Code、Slack 等）。在 Electron 应用中，将由“主进程”（负责窗口管理、系统集成）和“渲染进程”（负责显示界面）组成。可以使用流行的前端框架（如 React、Vue 或 Svelte）组织 UI，也可直接用原生 JS。

## 后端

后端算法逻辑选用 **Python** 实现。Python 拥有丰富的科学计算库，如 NumPy、SciPy、Pandas、SymPy 等，能高效处理数据和复杂计算。对于符号回归，可使用如 PySR、gplearn 等工具；对于蒙特卡罗模拟，可利用 NumPy 随机库和多线程加速。Python 环境管理推荐使用虚拟环境（venv）或 Poetry，确保依赖隔离和可复现。所有后端业务逻辑（数据预处理、建模算法、并行计算等）都在 Python 层实现。

## 通信机制（Electron 与 Python）

前端 Electron 与后端 Python 需要高效通讯。常见方案有：

* **REST/HTTP 接口**：在 Python 端启动一个本地 HTTP 服务器（如 Flask、FastAPI），Electron 通过 Fetch 或 axios 等发送请求交互。
* **ZeroRPC / gRPC**：使用跨语言的 RPC 框架（如 ZeroRPC、gRPC），在后端定义服务接口，前端调用。例如，可以用 [`zerorpc`](http://www.zerorpc.io/) 在 Electron 和 Python 之间建立绑定。
* **Node 扩展模块**：Electron 主进程可通过 `child_process` 调用 Python 可执行文件，或使用 npm 包如 [`python-shell`](https://github.com/extrabacon/python-shell) ，通过标准输入输出与 Python 交互。
* **IPC + 文件**：简单方式是 Electron 将参数写入临时文件或数据库，Python 读取后计算并将结果存回，Electron 再读取结果文件。这种方式实现简单，但适用场景有限。

根据项目需求，推荐**启用 Python 子进程**（可打包为独立可执行文件），并通过 HTTP 或 ZeroRPC 进行数据交换。例如，Electron 启动时用`child_process`执行 Python 程序，Python 端开启一个本地 RPC/HTTP 服务，Electron 主进程调用接口获取计算结果。这样可实现清晰的 UI/逻辑分离，且易于维护。

## 可视化方案

应用将大量呈现分析结果，因此需选用交互式图表库。候选技术包括：

* **Apache ECharts**：国产开源图表库，支持丰富图表类型且社区资源多，适合数据交互密集型应用。
* **D3.js / Chart.js / Plotly.js**：国际常用可视化库，可根据具体需求选择。Plotly 提供 Python 接口，可与后台无缝结合（生成图像供 Electron 显示）。
* **前端框架集成**：如结合 React 的 Recharts、VX（VisX）等也可实现现代交互效果。

界面设计应简洁直观，为科研用户提供友好体验。图表部分应支持放大、切换视图、数据导出等功能；必要时，可使用 WebGL 加速大数据可视化。

## 数据格式

内部数据交换和存储应使用常见的跨语言格式：

* **JSON**：Electron 与 Python 通信时传递参数和结果，可采用 JSON 格式。易于序列化对象、数组等结构，并被前端/后端均原生支持。
* **CSV/Excel**：用于与实验数据的互操作；用户导入导出时常用。Python 可用 Pandas 处理表格，Electron 可调用文件对话框读取。
* **二进制/数据库**：对于大型数据，亦可使用 SQLite 等轻量级数据库存储，以便索引查询。

规范的数据格式定义（如使用 JSON Schema）可避免前后端不匹配问题，并便于将来版本扩展兼容。

# 架构设计

系统整体采用**前后端分离**的架构，Electron 负责用户交互与界面显示，Python 后端负责核心算法。如下是一个示意架构图：

&#x20;*示例：Electron 应用多进程架构（图源自 [LogRocket 博客](https://blog.logrocket.com/advanced-electron-js-architecture/) ）*

如上图所示，Electron 包含一个 **主进程（Main Process）** 和一个或多个 **渲染进程（Renderer Process）**。主进程负责创建应用窗口、处理系统级事件、协调其他进程；每个渲染进程运行在独立的 Chromium 环境中，用于显示 HTML/CSS 构建的界面。为了避免界面阻塞，建议将耗时的任务放在后台：可以使用隐藏的渲染进程来执行计算，也可以在主进程调用 Python 服务。

前后端通信示意：

```text
      Electron 主进程/渲染进程（前端 GUI）           
           │         ↕ HTTP / RPC (ZeroRPC)           
+-----------------+      │      +-----------------------+
| Electron (JS)   |──────┼──────|  Python 服务 (Flask/ |
| 主/渲染进程     |      │      |  FastAPI / ZeroRPC)   |
+-----------------+      │      +-----------------------+
  (界面渲染、交互)           (算法逻辑、数据处理) 
```

示例：使用 Electron 作为“浏览器”+本地 Python 服务器的方案。上图中 Electron 启动 Python 子进程（本质上是启动一个本地 HTTP/RPC 服务器）；前端通过 HTTP API 或 ZeroRPC 客户端与之通信。Python 端会将所有核心业务逻辑封装成接口函数（如类方法），Electron 只需简单调用接口即可。

系统模块划分：

* **前端模块**：包含 Electron 主进程脚本、渲染进程（HTML/JS/CSS 或框架代码）、组件库、可视化逻辑。处理 UI 逻辑、用户输入、数据显示。
* **后端模块**：Python 包含数据处理层、算法实现层（符号回归、蒙特卡罗等）、辅助工具（如文件 I/O、日志）。按照功能拆分为多个子模块（如 `data_loader`, `symbolic_regression`, `monte_carlo`, `utils` 等）。
* **通信接口**：定义前后端协议，处理数据序列化/反序列化。可在项目中创建一个“API 定义”模块，明确可调用的接口及其参数/返回值。
* **持久化模块**：可选地使用轻量数据库（如 SQLite）或本地文件存储用户设置、历史数据等。

# 开发环境配置

以 **Arch Linux** 系统为例，确保开发环境现代化且可复现。

* **Git 和 GitHub 设置**：安装 Git（`pacman -S git`），全局配置用户名和邮箱（`git config --global user.name "姓名"`，`git config --global user.email "邮箱"`）。使用 SSH 密钥注册到 GitHub 账户，开启两步验证并启用 GitHub Actions 等服务。建议在仓库中采用 GitFlow 或类似分支策略（`main`存放稳定代码，`develop`用于日常开发，新功能使用 feature 分支，合并通过 Pull Request 并代码评审）。
* **Cursor IDE 安装与插件**：使用**Cursor AI IDE**作为开发环境，该 IDE 支持 Visual Studio Code 扩展并集成了强大的 AI 协助（即 Cursor Copilot 功能）。安装 Cursor 后，可加载常用插件（如 Python, ESLint 等）。Cursor 的 Copilot 支持自然语言指令，例如对代码编辑提出要求、自动重构函数等，极大提高算法开发效率。开发人员可在代码中用注释或在命令行对话框中输入“Rewrite this function using vectorized operations”之类指令，Cursor 将生成相应修改。Cursor 还可读取整个代码库上下文，快速定位问题和生成文档，便于团队协作。
* **Python 环境管理**：建议使用 **venv** 或 **Poetry** 来管理 Python 依赖。Poetry 是现代化的依赖管理和打包工具，使用 `pyproject.toml` 声明库依赖，自动隔离环境并生成锁文件。例如：`poetry init` 初始化项目，`poetry add numpy scipy flask` 安装依赖，`poetry install` 创建虚拟环境。Poetry 内置锁定功能保证不同开发者间依赖版本一致。在 Arch 中可通过 `pacman -S python-poetry` 安装，也可使用 pipx 安装。Python 版本建议为 3.10 以上，以使用最新语言特性。

# 项目初始化流程

* **仓库结构建议**：在 GitHub 创建新仓库，例如 `TCM-MultiComp-App`。建议采用如下目录结构：

  ```
  / (项目根)
  ├─ /frontend       # Electron 项目（主进程、渲染进程等）
  ├─ /backend        # Python 项目（算法库、API 服务）
  ├─ /docs           # 文档（需求说明、设计文档、用户手册草稿等）
  ├─ .gitignore
  ├─ README.md
  ├─ LICENSE
  ```

  前端和后端在同一仓库下，通过子目录区分。持续集成配置（如 GitHub Actions）放在 `.github/workflows` 下。`README.md` 简述项目和开发指南。`LICENSE` 文件选 MIT 或 Apache 2.0。版本控制始终提交可编译运行的最低功能代码，编写清晰的提交说明。

* **Electron 初始化**：在 `frontend` 目录执行 `npx create-electron-app .`（或使用 Electron Forge/Builder 脚手架）来生成基础项目模板。这将创建 `package.json`、`src/` 文件夹和示例文件。确保 Node.js 版本与 Electron 兼容，并且使用 `npm rebuild` 或 `electron-rebuild` 处理原生模块依赖。安装需要的前端库（例如 React/Angular/Vue、图表库、Electron IPC 工具等）。在 `package.json` 中设置启动脚本如 `"start": "electron ."`，以便开发时通过 `npm start` 启动应用。

* **Python 模块结构**：在 `backend` 目录下初始化 Python 包：创建 `pyproject.toml`（若用 Poetry）或 `requirements.txt`（若用 venv + pip）。目录示例：

  ```
  /backend
  ├─ /algorithms      # 符号回归、蒙特卡罗等算法实现
  ├─ /api             # 封装后端服务（Flask/FastAPI）
  ├─ /utils           # 工具函数（数据加载、日志等）
  ├─ __init__.py
  ├─ main.py          # 运行后端服务的入口
  └─ README.md
  ```

  在 `main.py` 中实现应用入口（例如启动 Flask 服务器或 ZeroRPC 服务）。`algorithms` 子包包含算法代码，每个复杂算法用独立模块分隔。`api` 子包定义路由或 RPC 服务，在此处理来自前端的请求并调用算法层。

* **配置脚本**：编写自动化脚本简化操作。例：`scripts/setup-dev.sh` 可安装依赖、初始化虚拟环境；`scripts/start.sh` 同时启动 Electron 和后端服务（在不同终端或后台运行）；`scripts/build-all.sh` 用于打包前端和编译后端。使用 Makefile 或 npm 脚本统一管理命令：如在 `frontend/package.json` 中设定 `"pack": "electron-builder"`，在 Python 项目中设定 `make build` 调用 PyInstaller。确保环境变量可配置（例如 `PORT`、日志级别、是否调试模式等），开发和生产环境设置不同配置文件。

# 开发计划与迭代阶段

采用**迭代开发**模式，将项目分阶段推进，持续交付原型并根据反馈完善：

* **M1 原型**：第一迭代重点完成**核心框架**和最简可运行原型。包括：Electron 前端框架搭建、基本窗口和菜单；Python 后端服务骨架（可响应测试请求）；前后端通信链路验证；基本数据导入界面。此阶段输出一个可部署的“空壳”应用，功能仅限于输入输出数据的通路。周期可设 2–3 周。
* **M2 MVP 实现**：第二迭代实现主要功能：集成符号回归算法（如使用 PySR），实现一套基本的多组分模型搜索；引入蒙特卡罗模拟核心代码；增加数据可视化组件（如一张简单的拟合图）；用户可以在界面上导入数据，触发算法计算，并看到图表结果。测试并修复主要缺陷。此阶段争取实现最低可用产品（MVP），可供内部演示和用户测试。周期 3–4 周。
* **M3 最终交付版本**：第三迭代完善所有功能，重点优化用户体验和性能。包括：实现完整的报表导出、参数调优界面、更多可视化类型（直方图、热力图等）；强化错误处理和日志；撰写完整文档；进行多平台打包（Windows/Linux）并测试安装程序；修复所有已知问题。准备用户手册、API 文档和演示材料。可能会多次迭代（数月）直至满足发布标准。

每个迭代结束后，团队应进行代码评审并更新里程碑。使用 GitHub 项目板（或其他敏捷工具）跟踪任务，在每次冲刺（Sprint）末交付可演示的增量成果。

# 测试策略

确保软件质量，需要从多层次进行测试：

* **单元测试**：为 Python 后端编写单元测试（可使用 [pytest](https://docs.pytest.org/)）。针对每个算法模块撰写测试用例，验证计算结果正确性（如已知公式的回归结果、随机模拟统计特性）。前端 JavaScript/TypeScript 可使用 [Jest](https://jestjs.io/) 或 Mocha 进行组件测试，确保 UI 逻辑正确。测试应覆盖边界情况和异常流。
* **集成测试**：测试前后端协作流程。可以模拟用户操作流程：通过自动化脚本或手动测试，验证 Electron 界面输入数据后能正确调用 Python 服务并返回预期结果。可利用 Electron 专用测试框架（如 [Spectron](https://www.electronjs.org/spectron)）进行端到端测试。
* **数据验证与边界测试**：对输入数据做健壮性测试：检查异常格式、缺失值或超出范围的数据如何处理；验证输出结果在数据极端情况下是否合理。对于蒙特卡罗模拟，测试随机数种子固定时是否输出可复现结果；对于符号回归，测试不同难度数据集的模型质量。
* **性能测试**：测量关键路径的执行时间，如一个完整分析流程的耗时，对大型数据做压力测试，并根据结果优化算法（例如多线程、向量化）。
* **持续集成（CI）**：配置 GitHub Actions，在每次提交时自动运行测试套件，确保新代码不破坏现有功能。可设定质量门槛（如覆盖率），并在 PR 合并前通过测试。

# 打包与部署方案

前端使用 **electron-builder** 打包，后端使用 **PyInstaller** 冻结为可执行文件，然后整合到安装程序中。具体策略如下：

* **Electron-builder 集成**：在 `frontend/package.json` 的 `build` 配置中，添加所需文件，比如 Python 可执行文件和资源文件。示例：

  ```json
  "build": {
    "files": [
      "main.exe",
      "index.js",
      "preload.js",
      "index.html",
      /* 其他资源 */
    ],
    "win": {
      "target": "nsis"
    },
    "linux": {
      "target": ["AppImage", "deb"]
    }
  }
  ```

  上例中，`main.exe` 为 PyInstaller 打包生成的 Windows 可执行文件，`nsis` 配置生成 Windows 安装程序。Linux 平台可构建 AppImage 或 Deb 包。

* **PyInstaller 冻结**：对 Python 后端，使用 PyInstaller 将 `main.py` 等脚本打包成单个可执行文件。例如：

  ```bash
  pyinstaller --onefile main.py
  ```

  这会在 `dist/` 目录生成跨平台可执行文件（Windows 上为 `main.exe`，Linux 上为无扩展名的二进制）。将生成的文件复制到 Electron 项目中，Electron 启动时可直接调用。例如 \[46] 中示例，将 `main.exe` 放在打包后的根目录，并在 Electron 主进程脚本中使用 `execFile` 启动。

* **跨平台构建说明**：Electron-builder 支持在一个平台上构建其它平台安装包，但有几点注意：

  * Windows 安装包（NSIS、MSI 等）一般在 Windows 系统或使用 wine 的 Docker 容器下构建最为可靠。可利用 [Electron Build Service](https://electronjs.org/docs/tutorial/multi-platform-build) 或 CI 服务（AppVeyor）打包。
  * Linux 打包（AppImage/DEB）可直接在 Linux 构建，electron-builder 内置支持多目标。示例命令：

    ```bash
    # 同时构建 Windows、Linux（需要 wine 环境）和 macOS（需在 macOS 上）安装包
    electron-builder -mwl
    ```

    参考文档建议使用 CI 脚本（Travis CI、GitHub Actions）执行，如文中所示。
  * MacOS 支持可选，需在 macOS 系统构建 DMG/PKG，并进行签名。

最终，在打包阶段：先在对应平台运行 PyInstaller 生成各自平台的 Python 可执行文件；然后执行 `electron-builder` 打包前端，并将可执行文件包含进安装包。这样用户安装后，无需单独安装 Python 环境即可运行完整应用。

# 文档与演示材料编写计划

* **用户手册**：编写详尽的使用手册（可用 Markdown 或 Sphinx/RST），包括安装指南、功能概览、操作步骤示例和常见问题。采用图文并茂的方式，说明数据导入、参数设置、结果解析等流程。用户手册应解释术语、提供示例数据集，以便最终用户快速上手。
* **API 文档**：为后端 Python 模块编写 API 文档，可使用 docstring + Sphinx 自动生成，或手工编写开发者文档。文档应列出所有可调用的接口、输入输出格式和示例，便于后续二次开发或维护。前端方面可在 README 中说明 Electron 项目结构和关键模块职责。
* **项目介绍与演示视频脚本**：准备项目简报和演示材料，在项目评审或推广时使用。内容包括项目背景、架构图、功能演示、使用案例等。视频脚本要结构清晰，可先撰写文本脚本，再录制演示画面和旁白。示范典型工作流程：如从数据加载到模型运行再到结果可视化。演示中应突出软件优势和易用性。

以上文档和材料应当纳入版本控制，与代码同步更新。可以在 GitHub 仓库中建立 `wiki` 或 `gh-pages` 分支来发布用户手册，并在 README 中添加导航链接。确保团队成员熟悉编写技术文档的规范，持续维护，使之与软件迭代同步更新。

**总结**：本软件工程计划覆盖了从需求分析、技术选型、架构设计到开发运维等全流程内容。通过模块化架构、版本控制和持续集成，可以实现**可持续迭代开发**：在每个迭代周期引入新功能并经过测试验证，保证软件质量和可维护性。同时利用 Cursor IDE 等先进工具辅助开发，提升算法实现效率。本计划注重跨平台兼容和团队协作，为中药多组分分析提供了全面的技术路线。所有技术选择和流程均可根据项目进展进行优化扩展，以适应实际需求。

**参考资料**：项目架构和技术选型参考了 Electron 和 Python 集成的实践文档；中药多组分分析背景参考了国家药监局技术指导；Python 环境管理参考了 Poetry 文档；Electron 包装与部署参考了相关案例与文档等。
