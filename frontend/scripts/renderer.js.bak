// å…¨å±€å˜é‡
let currentData = null;
let regressionModels = [];
let currentRegressionResult = null;
let currentSettings = {
    backendPort: 5000,
    autoStartBackend: true,
    theme: 'dark',
    language: 'zh-CN',
    defaultFormat: 'csv',
    autoSave: false
};

// APIåŸºç¡€URL
const API_BASE_URL = 'http://127.0.0.1:5000';

// å…¨å±€å‡½æ•°ï¼šæ˜¾ç¤ºæŒ‡å®šæ ‡ç­¾é¡µï¼ˆç”¨äºé¦–é¡µæŒ‰é’®ç‚¹å‡»ï¼‰
function showTab(tabName) {
    console.log(`ğŸ”„ åˆ‡æ¢åˆ°æ ‡ç­¾é¡µ: ${tabName}`);
    switchTab(tabName);
}

// DOM åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    initializeApp();
});

// åº”ç”¨åˆå§‹åŒ–
async function initializeApp() {
    console.log('ğŸš€ åˆå§‹åŒ–ä¸­è¯å¤šç»„åˆ†å‡åŒ–åˆ†æå®¢æˆ·ç«¯...');
    
    // åˆå§‹åŒ–è®¤è¯ç³»ç»Ÿ
    await authManager.initialize();
    
    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    setupEventListeners();
    
    // è®¾ç½®æ•°æ®ç®¡ç†äº‹ä»¶ç›‘å¬å™¨
    setupDataManagementListeners();
    
    // åŠ è½½è®¾ç½®
    loadSettings();
    
    // æ›´æ–°çŠ¶æ€æ 
    updateStatusBar();
    
    // ç«‹å³æ›´æ–°è¿æ¥çŠ¶æ€ä¸ºæ£€æŸ¥ä¸­
    updateConnectionStatus('æ£€æŸ¥ä¸­...');
    
    // æµ‹è¯•åç«¯è¿æ¥
    await testBackendConnection();
    
    // æ˜¾ç¤ºæ¬¢è¿é€šçŸ¥
    showNotification('æ¬¢è¿ä½¿ç”¨ä¸­è¯å¤šç»„åˆ†å‡åŒ–åˆ†æå®¢æˆ·ç«¯', 'success');
    
    // æµ‹è¯•ç”¨æˆ·ç®¡ç†åŠŸèƒ½
    if (authManager) {
        setTimeout(() => {
            authManager.testUserManagement();
        }, 2000);
    }
    
    console.log('âœ… åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
}

// è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
function setupEventListeners() {
    // å¯¼èˆªæŒ‰é’®äº‹ä»¶
    const navButtons = document.querySelectorAll('.nav-btn');
    navButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');
            switchTab(tabName);
        });
    });
    
    // æ–‡ä»¶è¾“å…¥äº‹ä»¶
    const regressionDataInput = document.getElementById('regression-data');
    if (regressionDataInput) {
        regressionDataInput.addEventListener('change', handleFileUpload);
    }
    
    // å¼€å§‹åˆ†ææŒ‰é’®äº‹ä»¶
    const startRegressionBtn = document.getElementById('start-regression');
    if (startRegressionBtn) {
        startRegressionBtn.addEventListener('click', startRegression);
    }
    
    // å¯¼å‡ºæ¨¡å‹æŒ‰é’®äº‹ä»¶
    const exportModelBtn = document.getElementById('export-model');
    if (exportModelBtn) {
        exportModelBtn.addEventListener('click', exportModel);
    }
    
    const startMonteCarloBtn = document.getElementById('start-monte-carlo');
    if (startMonteCarloBtn) {
        startMonteCarloBtn.addEventListener('click', startMonteCarlo);
    }
    
    // èœå•äº‹ä»¶ç›‘å¬
    if (window.electronAPI) {
        window.electronAPI.onMenuImportData(() => importData());
        window.electronAPI.onMenuExportResults(() => exportResults());
        window.electronAPI.onMenuSymbolicRegression(() => switchTab('regression'));
        window.electronAPI.onMenuMonteCarlo(() => switchTab('monte-carlo'));
        window.electronAPI.onMenuAbout(() => showAboutDialog());
    }
    
    // è®¾ç½®å˜æ›´äº‹ä»¶
    const settingInputs = document.querySelectorAll('#settings input, #settings select');
    settingInputs.forEach(input => {
        input.addEventListener('change', function() {
            updateSetting(this.id, this.value || this.checked);
        });
    });
}

// åˆ‡æ¢æ ‡ç­¾é¡µ
function switchTab(tabName) {
    // è·å–å½“å‰æ¿€æ´»çš„æ ‡ç­¾é¡µ
    const currentActiveTab = document.querySelector('.tab-content.active');
    const targetTab = document.getElementById(tabName);
    
    if (!targetTab) {
        console.error('âŒ æ‰¾ä¸åˆ°ç›®æ ‡æ ‡ç­¾é¡µ:', tabName);
        return;
    }
    
    // å¦‚æœç‚¹å‡»çš„æ˜¯å½“å‰æ¿€æ´»çš„æ ‡ç­¾é¡µï¼Œä¸åšä»»ä½•æ“ä½œ
    if (currentActiveTab === targetTab) {
        return;
    }
    
    // åˆ›å»ºé¡µé¢åˆ‡æ¢æŒ‡ç¤ºå™¨
    let transitionIndicator = document.querySelector('.page-transition-indicator');
    if (!transitionIndicator) {
        transitionIndicator = document.createElement('div');
        transitionIndicator.className = 'page-transition-indicator';
        document.body.appendChild(transitionIndicator);
    }
    
    // æ˜¾ç¤ºé¡µé¢åˆ‡æ¢æŒ‡ç¤ºå™¨
    transitionIndicator.classList.add('active');
    
    // ç§»é™¤æ‰€æœ‰å¯¼èˆªæŒ‰é’®çš„æ¿€æ´»çŠ¶æ€
    const navButtons = document.querySelectorAll('.nav-btn');
    navButtons.forEach(button => {
        button.classList.remove('active');
    });
    
    // æ¿€æ´»å¯¹åº”çš„å¯¼èˆªæŒ‰é’®
    const targetButton = document.querySelector(`[data-tab="${tabName}"]`);
    if (targetButton) {
        targetButton.classList.add('active');
    }
    
    // æ›´ä¸æ»‘çš„é¡µé¢åˆ‡æ¢åŠ¨ç”»
    if (currentActiveTab) {
        // ä¸ºå½“å‰é¡µé¢æ·»åŠ è¿‡æ¸¡çŠ¶æ€
        currentActiveTab.classList.add('transitioning');
        
        // å½“å‰é¡µé¢æ·¡å‡º - ä½¿ç”¨æ›´é•¿çš„åŠ¨ç”»æ—¶é—´
        currentActiveTab.classList.add('fade-out');
        
        // å»¶è¿Ÿæ˜¾ç¤ºç›®æ ‡é¡µé¢ï¼Œç¡®ä¿è¿‡æ¸¡æ›´ä¸æ»‘
        setTimeout(() => {
            // éšè—å½“å‰é¡µé¢
            currentActiveTab.classList.remove('active', 'fade-out', 'transitioning');
            
            // æ˜¾ç¤ºç›®æ ‡é¡µé¢å¹¶æ·¡å…¥
            targetTab.classList.add('active', 'fade-in');
            
            // ç§»é™¤è¿‡æ¸¡çŠ¶æ€
            targetTab.classList.remove('transitioning');
            
            // ç§»é™¤æ·¡å…¥ç±»ï¼Œä¿æŒæ¿€æ´»çŠ¶æ€
            setTimeout(() => {
                targetTab.classList.remove('fade-in');
                
                // éšè—é¡µé¢åˆ‡æ¢æŒ‡ç¤ºå™¨
                transitionIndicator.classList.remove('active');
                
                // å»¶è¿Ÿç§»é™¤æŒ‡ç¤ºå™¨å…ƒç´ 
                setTimeout(() => {
                    if (transitionIndicator.parentElement) {
                        transitionIndicator.remove();
                    }
                }, 300);
                
            }, 500); // å¢åŠ åŠ¨ç”»æ—¶é—´
            
        }, 300); // å¢åŠ å»¶è¿Ÿæ—¶é—´ï¼Œè®©è¿‡æ¸¡æ›´ä¸æ»‘
    } else {
        // å¦‚æœæ²¡æœ‰å½“å‰æ¿€æ´»çš„é¡µé¢ï¼Œç›´æ¥æ˜¾ç¤ºç›®æ ‡é¡µé¢
        targetTab.classList.add('active');
        
        // éšè—é¡µé¢åˆ‡æ¢æŒ‡ç¤ºå™¨
        setTimeout(() => {
            transitionIndicator.classList.remove('active');
            setTimeout(() => {
                if (transitionIndicator.parentElement) {
                    transitionIndicator.remove();
                }
            }, 300);
        }, 200);
    }
    
    // ç‰¹æ®Šå¤„ç†ï¼šç”¨æˆ·ç®¡ç†é¡µé¢è‡ªåŠ¨åŠ è½½ç”¨æˆ·åˆ—è¡¨
    if (tabName === 'user-management') {
        console.log('ğŸ” åˆ‡æ¢åˆ°ç”¨æˆ·ç®¡ç†é¡µé¢');
        if (authManager && authManager.currentUser && authManager.currentUser.role === 'admin') {
            console.log('ğŸ” ç”¨æˆ·æ˜¯ç®¡ç†å‘˜ï¼Œè‡ªåŠ¨åŠ è½½ç”¨æˆ·åˆ—è¡¨');
            setTimeout(() => {
                authManager.loadUsers();
            }, 800); // å»¶è¿Ÿåˆ°åŠ¨ç”»å®Œæˆåæ‰§è¡Œ
        } else {
            console.log('ğŸ” ç”¨æˆ·ä¸æ˜¯ç®¡ç†å‘˜ï¼Œæ˜¾ç¤ºæƒé™ä¸è¶³');
            const usersTable = document.getElementById('users-table');
            if (usersTable) {
                usersTable.innerHTML = '<p>æƒé™ä¸è¶³ï¼Œåªæœ‰ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹ç”¨æˆ·åˆ—è¡¨</p>';
            }
        }
    }
    
    // ç‰¹æ®Šå¤„ç†ï¼šæ•°æ®ç®¡ç†é¡µé¢è‡ªåŠ¨åŠ è½½æ•°æ®æ¨¡å‹åˆ—è¡¨
    if (tabName === 'data-management') {
        console.log('ğŸ” åˆ‡æ¢åˆ°æ•°æ®ç®¡ç†é¡µé¢');
        if (authManager && authManager.currentUser && authManager.currentUser.role === 'admin') {
            console.log('ğŸ” ç”¨æˆ·æ˜¯ç®¡ç†å‘˜ï¼Œè‡ªåŠ¨åŠ è½½æ•°æ®æ¨¡å‹åˆ—è¡¨');
            setTimeout(() => {
                loadDataModels();
            }, 800); // å»¶è¿Ÿåˆ°åŠ¨ç”»å®Œæˆåæ‰§è¡Œ
        } else {
            console.log('ğŸ” ç”¨æˆ·ä¸æ˜¯ç®¡ç†å‘˜ï¼Œæ˜¾ç¤ºæƒé™ä¸è¶³');
            const dataPreview = document.getElementById('data-preview');
            if (dataPreview) {
                dataPreview.innerHTML = '<p>æƒé™ä¸è¶³ï¼Œåªæœ‰ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹æ•°æ®æ¨¡å‹</p>';
            }
        }
    }
    
    // ç‰¹æ®Šå¤„ç†ï¼šè’™ç‰¹å¡æ´›é‡‡æ ·é¡µé¢è‡ªåŠ¨åŠ è½½æ•°æ®æ¨¡å‹åˆ—è¡¨
    if (tabName === 'monte-carlo') {
        console.log('ğŸ” åˆ‡æ¢åˆ°è’™ç‰¹å¡æ´›é‡‡æ ·é¡µé¢');
        setTimeout(() => {
            loadDataModelsForMonteCarlo();
        }, 800); // å»¶è¿Ÿåˆ°åŠ¨ç”»å®Œæˆåæ‰§è¡Œ
    }
    
    // æ›´æ–°çŠ¶æ€æ 
    updateStatusBar();
    
    // æ»šåŠ¨åˆ°é¡µé¢é¡¶éƒ¨ï¼Œç¡®ä¿è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒ
    setTimeout(() => {
        const mainContent = document.querySelector('.main-content');
        if (mainContent) {
            mainContent.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
    }, 100);
}

// å¤„ç†æ–‡ä»¶ä¸Šä¼ 
async function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    showLoading('æ­£åœ¨ä¸Šä¼ æ–‡ä»¶...');
    
    try {
        const formData = new FormData();
        formData.append('file', file);
        
        const response = await fetch(`${API_BASE_URL}/api/data/upload`, {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.message || 'æ–‡ä»¶ä¸Šä¼ å¤±è´¥');
        }
        
        // ä½¿ç”¨APIè¿”å›çš„æ•°æ®
        currentData = {
            data: result.result.data_preview,
            headers: result.result.columns_list,
            rows: result.result.rows,
            columns: result.result.columns,
            filename: result.result.filename
        };
        
        // æ›´æ–°ç›®æ ‡åˆ—é€‰æ‹©
        updateTargetColumnSelect(result.result.columns_list);
        
        // æ›´æ–°ç‰¹å¾åˆ—å¤é€‰æ¡†
        updateFeatureColumnsCheckboxes(result.result.columns_list);

        // æ¸²æŸ“é¢„è§ˆè¡¨æ ¼
        renderRegressionPreviewTable(currentData.headers, currentData.data);
        
        showNotification('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ', 'success');
    } catch (error) {
        showNotification('æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ' + error.message, 'error');
        console.error('âŒ æ–‡ä»¶ä¸Šä¼ é”™è¯¯:', error);
    } finally {
        hideLoading();
    }
}

// è§£ææ–‡ä»¶
async function parseFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(e) {
            try {
                const content = e.target.result;
                const data = parseCSV(content);
                resolve(data);
            } catch (error) {
                reject(error);
            }
        };
        
        reader.onerror = function() {
            reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
        };
        
        reader.readAsText(file);
    });
}

// è§£æCSVå†…å®¹
function parseCSV(content) {
    const lines = content.trim().split('\n');
    const headers = lines[0].split(',').map(h => h.trim());
    const data = [];
    
    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        const row = {};
        
        headers.forEach((header, index) => {
            const value = values[index] ? values[index].trim() : '';
            row[header] = isNaN(value) ? value : parseFloat(value);
        });
        
        data.push(row);
    }
    
    return {
        data: data,
        headers: headers,
        rows: data.length,
        columns: headers.length
    };
}

// æ›´æ–°ç›®æ ‡åˆ—é€‰æ‹©
function updateTargetColumnSelect(columns) {
    const select = document.getElementById('target-column');
    if (!select) return;
    
    select.innerHTML = '<option value="">è¯·é€‰æ‹©ç›®æ ‡å˜é‡</option>';
    columns.forEach(column => {
        const option = document.createElement('option');
        option.value = column;
        option.textContent = column;
        select.appendChild(option);
    });
}

// æ›´æ–°ç‰¹å¾åˆ—å¤é€‰æ¡†
function updateFeatureColumnsCheckboxes(columns) {
    const container = document.getElementById('feature-columns');
    if (!container) return;
    
    container.innerHTML = '';
    columns.forEach(column => {
        const div = document.createElement('div');
        div.className = 'checkbox-item';
        div.innerHTML = `
            <input type="checkbox" id="feature-${column}" value="${column}" checked>
            <label for="feature-${column}">${column}</label>
        `;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œè®©æ•´ä¸ªåŒºåŸŸå¯ç‚¹å‡»
        div.addEventListener('click', function(e) {
            // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯å¤é€‰æ¡†æœ¬èº«ï¼Œåˆ™åˆ‡æ¢å¤é€‰æ¡†çŠ¶æ€
            if (e.target.type !== 'checkbox') {
                const checkbox = this.querySelector('input[type="checkbox"]');
                checkbox.checked = !checkbox.checked;
            }
        });
        
        container.appendChild(div);
    });
}

// æ¸²æŸ“æ•°æ®é¢„è§ˆè¡¨æ ¼
function renderRegressionPreviewTable(headers, rows) {
    const host = document.getElementById('regression-data-preview');
    if (!host) return;
    if (!headers || !rows || rows.length === 0) {
        host.innerHTML = '<p>æš‚æ— æ•°æ®</p>';
        return;
    }
    const previewRows = rows.slice(0, 8);
    const thead = `<thead><tr>${headers.map(h=>`<th>${h}</th>`).join('')}</tr></thead>`;
    const tbody = `<tbody>${previewRows.map(r=>`<tr>${headers.map(h=>`<td>${r[h] ?? ''}</td>`).join('')}</tr>`).join('')}</tbody>`;
    host.innerHTML = `<div class="data-table"><table>${thead}${tbody}</table></div>`;
}

// è®­ç»ƒ/æµ‹è¯•æ»‘å—è”åŠ¨
document.addEventListener('input', (e) => {
    if (e.target && e.target.id === 'train-ratio') {
        const train = Number(e.target.value);
        const test = 100 - train;
        const trainLabel = document.getElementById('train-ratio-label');
        const testLabel = document.getElementById('test-ratio-label');
        if (trainLabel) trainLabel.textContent = `${train}%`;
        if (testLabel) testLabel.textContent = `${test}%`;
    }
});

// å¼€å§‹ç¬¦å·å›å½’åˆ†æ
async function startRegression() {
    console.log('ğŸ” å¼€å§‹ç¬¦å·å›å½’åˆ†æ...');
    
    const targetColumn = document.getElementById('target-column').value;
    const featureCheckboxes = document.querySelectorAll('#feature-columns input[type="checkbox"]:checked');
    const populationSize = parseInt(document.getElementById('population-size').value) || 100;
    const generations = parseInt(document.getElementById('generations').value) || 50;
    
    console.log('ğŸ“Š åˆ†æå‚æ•°:', {
        targetColumn,
        featureCount: featureCheckboxes.length,
        populationSize,
        generations,
        hasData: !!currentData
    });
    
    if (!targetColumn) {
        showNotification('è¯·é€‰æ‹©ç›®æ ‡å˜é‡', 'warning');
        return;
    }
    
    if (featureCheckboxes.length === 0) {
        showNotification('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªç‰¹å¾å˜é‡', 'warning');
        return;
    }
    
    if (!currentData) {
        showNotification('è¯·å…ˆä¸Šä¼ æ•°æ®', 'warning');
        return;
    }
    
    const featureColumns = Array.from(featureCheckboxes).map(cb => cb.value);
    
    showLoading('æ­£åœ¨è¿›è¡Œç¬¦å·å›å½’åˆ†æ...');
    
    try {
        const result = await performSymbolicRegression({
            data: currentData.data,
            target_column: targetColumn,
            feature_columns: featureColumns,
            population_size: populationSize,
            generations: generations,
            data_source: currentData.filename || "æ•°æ®æº"
        });
        
        // ä¿å­˜å½“å‰å›å½’ç»“æœ
        currentRegressionResult = result;
        
        // ä¿å­˜æ¨¡å‹åˆ°åˆ—è¡¨
        regressionModels.push(result);
        updateRegressionModelList();
        
        displayRegressionResults(result);
        showNotification('ç¬¦å·å›å½’åˆ†æå®Œæˆ', 'success');
        
        // å¦‚æœè¿”å›äº†æ•°æ®æ¨¡å‹IDï¼Œæ˜¾ç¤ºæç¤º
        if (result.data_model_id) {
            showNotification(`æ•°æ®æ¨¡å‹å·²è‡ªåŠ¨åˆ›å»º: ${result.data_model_id}`, 'info');
        }
    } catch (error) {
        showNotification('ç¬¦å·å›å½’åˆ†æå¤±è´¥: ' + error.message, 'error');
        console.error('âŒ ç¬¦å·å›å½’åˆ†æé”™è¯¯:', error);
    } finally {
        hideLoading();
    }
}

// æ‰§è¡Œç¬¦å·å›å½’ï¼ˆçœŸå®APIè°ƒç”¨ï¼‰
async function performSymbolicRegression(params) {
    try {
        const response = await fetch(`${API_BASE_URL}/api/regression/analyze`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(params)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.message || 'APIè°ƒç”¨å¤±è´¥');
        }
        
        return result.result;
    } catch (error) {
        console.error('APIè°ƒç”¨å¤±è´¥:', error);
        throw error;
    }
}

// æ˜¾ç¤ºå›å½’ç»“æœ
function displayRegressionResults(result) {
    const container = document.getElementById('regression-results');
    if (!container) return;
    
    // è§£æè¡¨è¾¾å¼ï¼Œæå–ç›®æ ‡å˜é‡ã€ç‰¹å¾å˜é‡å’Œå¸¸æ•°
    const expression = result.expression || '';
    const targetVariable = result.target_variable || 'Y';
    const constants = result.constants || {};
    
    // ç”ŸæˆLaTeXå…¬å¼ï¼ˆä¼šæ›´æ–°constantså¯¹è±¡ï¼‰
    const latexFormula = generateLatexFormula(expression, targetVariable, constants);
    
    container.innerHTML = `
        <div class="result-item">
            <h4>å›å½’è¡¨è¾¾å¼</h4>
            <div class="regression-formula-container">
                <div class="regression-formula">
                    $${latexFormula}$
                </div>
                ${Object.keys(constants).length > 0 ? `
                <div class="regression-constants">
                    <h5>å¸¸æ•°å®šä¹‰</h5>
                    <div class="constant-list">
                        ${Object.entries(constants).map(([key, value]) => 
                            `<div class="constant-item">$${key} = ${value}$$</div>`
                        ).join('')}
                    </div>
                </div>
                ` : ''}
            </div>
        </div>
        
        <div class="result-item">
            <h4>æ¨¡å‹æ€§èƒ½</h4>
            <div class="performance-metrics">
                <div class="performance-metric">
                    <div class="metric-label">å†³å®šç³»æ•°</div>
                    <div class="metric-value">${result.r2.toFixed(3)}</div>
                    <div class="metric-unit">RÂ²</div>
                </div>
                <div class="performance-metric">
                    <div class="metric-label">å‡æ–¹è¯¯å·®</div>
                    <div class="metric-value">${result.mse.toFixed(3)}</div>
                    <div class="metric-unit">MSE</div>
                </div>
            </div>
        </div>
        
        <div class="result-item">
            <h4>ç‰¹å¾é‡è¦æ€§</h4>
            <div class="feature-importance">
                ${result.feature_importance.map(f => `
                    <div class="feature-importance-item">
                        <div class="feature-name">${f.feature}</div>
                        <div class="importance-bar">
                            <div class="importance-fill" style="width: ${f.importance * 100}%"></div>
                        </div>
                        <div class="importance-value">${f.importance.toFixed(3)}</div>
                    </div>
                `).join('')}
            </div>
        </div>
        
        <div class="result-item">
            <h4>é¢„æµ‹ç»“æœ</h4>
            <p>æ ·æœ¬æ•°é‡: ${result.predictions.length}</p>
            <button class="btn-secondary" onclick="visualizeResults(${result.id})">æŸ¥çœ‹å›¾è¡¨</button>
        </div>
    `;
    
    // é‡æ–°æ¸²æŸ“MathJax
    if (window.MathJax && window.MathJax.typesetPromise) {
        console.log('å¼€å§‹æ¸²æŸ“MathJaxå…¬å¼:', latexFormula);
        MathJax.typesetPromise([container]).then(() => {
            console.log('MathJaxæ¸²æŸ“å®Œæˆ');
        }).catch((err) => console.error('MathJaxæ¸²æŸ“é”™è¯¯:', err));
    } else {
        // å¦‚æœMathJaxè¿˜æ²¡åŠ è½½å®Œæˆï¼Œç­‰å¾…åŠ è½½
        console.log('MathJaxæœªåŠ è½½ï¼Œç­‰å¾…åŠ è½½...');
        const checkMathJax = () => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                console.log('MathJaxå·²åŠ è½½ï¼Œå¼€å§‹æ¸²æŸ“:', latexFormula);
                MathJax.typesetPromise([container]).then(() => {
                    console.log('MathJaxæ¸²æŸ“å®Œæˆ');
                }).catch((err) => console.error('MathJaxæ¸²æŸ“é”™è¯¯:', err));
            } else {
                setTimeout(checkMathJax, 100);
            }
        };
        checkMathJax();
    }
    
    // å¯ç”¨å¯¼å‡ºæ¨¡å‹æŒ‰é’®
    const exportModelBtn = document.getElementById('export-model');
    if (exportModelBtn) {
        exportModelBtn.disabled = false;
    }
}

// ç”ŸæˆLaTeXå…¬å¼çš„å‡½æ•°
function generateLatexFormula(expression, targetVariable, constants) {
    if (!expression) return `${targetVariable} = 0`;
    
    // å°†è¡¨è¾¾å¼ä¸­çš„æ•°å­—æ›¿æ¢ä¸ºcä¸‹æ ‡æ ¼å¼
    let processedExpression = expression;
    
    // æå–æ‰€æœ‰æ•°å­—ï¼ˆåŒ…æ‹¬å°æ•°ï¼‰ï¼Œä½†æ’é™¤å˜é‡åä¸­çš„æ•°å­—
    const numberPattern = /(?<![a-zA-Z_])\b-?\d+\.?\d*\b/g;
    const numbers = expression.match(numberPattern) || [];
    
    // ä¸ºæ¯ä¸ªæ•°å­—åˆ›å»ºå¸¸æ•°å®šä¹‰ï¼Œé¿å…é‡å¤
    const constantMap = {};
    const usedNumbers = new Set();
    
    numbers.forEach((num) => {
        if (!usedNumbers.has(num)) {
            const index = Object.keys(constantMap).length;
            const constantName = `c_{${index}}`;
            constantMap[constantName] = parseFloat(num);
            usedNumbers.add(num);
            
            // æ›¿æ¢æ‰€æœ‰ç›¸åŒçš„æ•°å­—
            const regex = new RegExp(`\\b${num.replace(/\./g, '\\.')}\\b`, 'g');
            processedExpression = processedExpression.replace(regex, constantName);
        }
    });
    
    // æ¸…ç©ºä¼ å…¥çš„constantså¯¹è±¡ï¼Œç„¶åä½¿ç”¨æ–°ç”Ÿæˆçš„å¸¸æ•°
    Object.keys(constants).forEach(key => delete constants[key]);
    Object.assign(constants, constantMap);
    
    // è½¬æ¢ä¸ºLaTeXæ ¼å¼
    let latex = processedExpression
        .replace(/\*/g, '\\cdot ')
        .replace(/\//g, '\\frac{')
        .replace(/\^/g, '^')
        .replace(/\(/g, '\\left(')
        .replace(/\)/g, '\\right)');
    
    // å¤„ç†åˆ†æ•°
    if (latex.includes('\\frac{')) {
        latex = latex.replace(/\\frac\{([^}]+)\}\/([^\\s]+)/g, '\\frac{$1}{$2}');
    }
    
    return `${targetVariable} = ${latex}`;
}

// å¯¼å‡ºæ¨¡å‹åŠŸèƒ½
async function exportModel() {
    try {
        // è·å–å½“å‰åˆ†æçš„æ•°æ®æ–‡ä»¶å
        const dataFileInput = document.getElementById('regression-data');
        const targetColumn = document.getElementById('target-column').value;
        
        if (!dataFileInput.files[0] || !targetColumn) {
            showNotification('è¯·å…ˆå®Œæˆç¬¦å·å›å½’åˆ†æ', 'warning');
            return;
        }
        
        const dataFileName = dataFileInput.files[0].name.replace('.csv', '');
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        
        // è·å–ç‰¹å¾å˜é‡
        const featureCheckboxes = document.querySelectorAll('#feature-columns input[type="checkbox"]:checked');
        const featureColumns = Array.from(featureCheckboxes).map(cb => cb.value);
        
        // ç”Ÿæˆæœ‰åŒºåˆ†åº¦çš„æ–‡ä»¶å
        let featuresSummary = '';
        if (featureColumns.length <= 3) {
            featuresSummary = featureColumns.join('_');
        } else {
            featuresSummary = `${featureColumns[0]}_${featureColumns[1]}_${featureColumns[2]}+${featureColumns.length-3}ä¸ª`;
        }
        
        // ç”Ÿæˆæ–‡ä»¶åï¼šç¬¦å·å›å½’_è¯æ•ˆ_ç‰¹å¾æ‘˜è¦_æ•°æ®æº_æ—¶é—´æˆ³.json
        const modelFileName = `ç¬¦å·å›å½’_${targetColumn}_${featuresSummary}_${dataFileName}_${timestamp}.json`;
        
        // è·å–æœ€æ–°çš„å›å½’ç»“æœ
        const resultsContainer = document.getElementById('regression-results');
        if (!resultsContainer || resultsContainer.children.length === 0) {
            showNotification('æ²¡æœ‰å¯å¯¼å‡ºçš„æ¨¡å‹æ•°æ®', 'warning');
            return;
        }
        
        // æ„å»ºæ¨¡å‹æ•°æ®
        const modelData = {
            data_file: dataFileName,
            target_column: targetColumn,
            export_time: new Date().toISOString(),
            model_info: {
                expression: currentRegressionResult?.expression || '',
                r2: currentRegressionResult?.r2 || 0,
                mse: currentRegressionResult?.mse || 0,
                feature_importance: currentRegressionResult?.feature_importance || []
            }
        };
        
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const dataStr = JSON.stringify(modelData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = modelFileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        showNotification(`æ¨¡å‹å·²å¯¼å‡º: ${modelFileName}`, 'success');
        
    } catch (error) {
        console.error('å¯¼å‡ºæ¨¡å‹å¤±è´¥:', error);
        showNotification('å¯¼å‡ºæ¨¡å‹å¤±è´¥: ' + error.message, 'error');
    }
}

// æ›´æ–°å›å½’æ¨¡å‹åˆ—è¡¨
function updateRegressionModelList() {
    const select = document.getElementById('mc-model');
    if (!select) return;
    
    select.innerHTML = '<option value="">è¯·é€‰æ‹©å›å½’æ¨¡å‹</option>';
    regressionModels.forEach(model => {
        const option = document.createElement('option');
        option.value = model.id;
        option.textContent = `æ¨¡å‹ ${model.id} (RÂ²=${model.r2.toFixed(3)})`;
        select.appendChild(option);
    });
}

// å¼€å§‹è’™ç‰¹å¡æ´›é‡‡æ ·åˆ†æ
async function startMonteCarlo() {
    const dataModelId = document.getElementById('mc-data-model').value;
    const iterations = parseInt(document.getElementById('mc-iterations').value);
    const targetEfficacy = parseFloat(document.getElementById('target-efficacy').value);
    const tolerance = parseFloat(document.getElementById('tolerance').value);
    
    if (!dataModelId) {
        showNotification('è¯·é€‰æ‹©æ•°æ®æ¨¡å‹', 'warning');
        return;
    }
    
    if (!targetEfficacy) {
        showNotification('è¯·è¾“å…¥ç›®æ ‡è¯æ•ˆå€¼', 'warning');
        return;
    }
    
    showLoading('æ­£åœ¨è¿›è¡Œè’™ç‰¹å¡æ´›é‡‡æ ·åˆ†æ...');
    
    try {
        const result = await performMonteCarloAnalysis({
            model_id: dataModelId,
            iterations,
            target_efficacy: targetEfficacy,
            tolerance
        });
        
        displayMonteCarloResults(result);
        showNotification('è’™ç‰¹å¡æ´›é‡‡æ ·åˆ†æå®Œæˆ', 'success');
        
        // å¦‚æœè¿”å›äº†æ•°æ®æ¨¡å‹IDï¼Œæ˜¾ç¤ºæç¤º
        if (result.data_model_id) {
            showNotification(`æ•°æ®æ¨¡å‹å·²æ›´æ–°: ${result.data_model_id}`, 'info');
        }
        
        // é‡æ–°åŠ è½½æ•°æ®æ¨¡å‹åˆ—è¡¨
        setTimeout(() => {
            loadDataModels();
        }, 1000);
    } catch (error) {
        showNotification('è’™ç‰¹å¡æ´›é‡‡æ ·åˆ†æå¤±è´¥: ' + error.message, 'error');
        console.error('âŒ è’™ç‰¹å¡æ´›é‡‡æ ·åˆ†æé”™è¯¯:', error);
    } finally {
        hideLoading();
    }
}

// æ‰§è¡Œè’™ç‰¹å¡æ´›é‡‡æ ·åˆ†æï¼ˆçœŸå®APIè°ƒç”¨ï¼‰
async function performMonteCarloAnalysis(params) {
    try {
        const response = await fetch(`${API_BASE_URL}/api/monte-carlo-sampling/analyze`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(params)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.message || 'APIè°ƒç”¨å¤±è´¥');
        }
        
        return result.result;
    } catch (error) {
        console.error('APIè°ƒç”¨å¤±è´¥:', error);
        throw error;
    }
}

// æ˜¾ç¤ºè’™ç‰¹å¡æ´›é‡‡æ ·ç»“æœ
function displayMonteCarloResults(result) {
    const container = document.getElementById('monte-carlo-results');
    if (!container) return;
    
    container.innerHTML = `
        <div class="result-item">
            <h4>åˆ†æå‚æ•°</h4>
            <p>æ¨¡æ‹Ÿæ¬¡æ•°: ${result.iterations}</p>
            <p>ç›®æ ‡è¯æ•ˆ: ${result.target_efficacy}</p>
            <p>å®¹å·®: ${result.tolerance}</p>
        </div>
        
        <div class="result-item">
            <h4>åˆ†æç»“æœ</h4>
            <p>æœ‰æ•ˆæ ·æœ¬æ•°: ${result.valid_samples}</p>
            <p>æˆåŠŸç‡: ${(result.success_rate * 100).toFixed(1)}%</p>
            <p>åˆ†ææ—¶é—´: ${result.analysis_time}ç§’</p>
        </div>
        
        <div class="result-item">
            <h4>æœ€ä¼˜é…æ¯”èŒƒå›´</h4>
            <ul>
                ${result.optimal_ranges.map(r => 
                    `<li>${r.component}: ${r.min.toFixed(2)} - ${r.max.toFixed(2)} (å‡å€¼: ${r.mean.toFixed(2)})</li>`
                ).join('')}
            </ul>
        </div>
        
        <div class="result-item">
            <h4>æ“ä½œ</h4>
            <button class="btn-secondary" onclick="exportMonteCarloResults(${result.iterations})">å¯¼å‡ºç»“æœ</button>
        </div>
    `;
}

// å¯¼å…¥æ•°æ®
async function importData() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv,.xlsx,.xls';
    
    input.onchange = async function(e) {
        const file = e.target.files[0];
        if (file) {
            try {
                const data = await parseFile(file);
                currentData = data;
                updateTargetColumnSelect(Object.keys(data.data[0]));
                updateFeatureColumnsCheckboxes(Object.keys(data.data[0]));
                showNotification('æ•°æ®å¯¼å…¥æˆåŠŸ', 'success');
            } catch (error) {
                showNotification('æ•°æ®å¯¼å…¥å¤±è´¥: ' + error.message, 'error');
            }
        }
    };
    
    input.click();
}

// å¯¼å‡ºç»“æœ
async function exportResults() {
    if (regressionModels.length === 0) {
        showNotification('æ²¡æœ‰å¯å¯¼å‡ºçš„ç»“æœ', 'warning');
        return;
    }
    
    const dataStr = JSON.stringify(regressionModels, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `regression_results_${Date.now()}.json`;
    link.click();
    
    showNotification('ç»“æœå¯¼å‡ºæˆåŠŸ', 'success');
}

// å¯åŠ¨åç«¯æœåŠ¡
async function startBackendService() {
    try {
        // æ£€æŸ¥åç«¯å¥åº·çŠ¶æ€
        const healthResponse = await fetch(`${API_BASE_URL}/api/health`);
        if (healthResponse.ok) {
            updateConnectionStatus('å·²è¿æ¥');
            showNotification('åç«¯æœåŠ¡å·²è¿æ¥', 'success');
        } else {
            updateConnectionStatus('è¿æ¥å¤±è´¥');
            showNotification('åç«¯æœåŠ¡è¿æ¥å¤±è´¥', 'error');
        }
    } catch (error) {
        updateConnectionStatus('è¿æ¥å¤±è´¥');
        showNotification('åç«¯æœåŠ¡è¿æ¥å¤±è´¥: ' + error.message, 'error');
    }
}

// æµ‹è¯•åç«¯è¿æ¥
async function testBackendConnection() {
    try {
        const response = await fetch(`${API_BASE_URL}/api/health`);
        if (response.ok) {
            const data = await response.json();
            updateConnectionStatus('å·²è¿æ¥');
            showNotification(`åç«¯è¿æ¥æ­£å¸¸: ${data.service}`, 'success');
            return true;
        } else {
            updateConnectionStatus('è¿æ¥å¤±è´¥');
            showNotification('åç«¯è¿æ¥å¤±è´¥', 'error');
            return false;
        }
    } catch (error) {
        updateConnectionStatus('è¿æ¥å¤±è´¥');
        showNotification('åç«¯è¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
        return false;
    }
}

// ä¿å­˜è®¾ç½®
async function saveSettings() {
    try {
        // è¿™é‡Œåº”è¯¥ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨æˆ–é…ç½®æ–‡ä»¶
        localStorage.setItem('tcm-settings', JSON.stringify(currentSettings));
        showNotification('è®¾ç½®ä¿å­˜æˆåŠŸ', 'success');
    } catch (error) {
        showNotification('è®¾ç½®ä¿å­˜å¤±è´¥: ' + error.message, 'error');
    }
}

// åŠ è½½è®¾ç½®
function loadSettings() {
    try {
        const saved = localStorage.getItem('tcm-settings');
        if (saved) {
            currentSettings = { ...currentSettings, ...JSON.parse(saved) };
        }
        
        // åº”ç”¨è®¾ç½®åˆ°ç•Œé¢
        Object.keys(currentSettings).forEach(key => {
            const element = document.getElementById(key);
            if (element) {
                if (element.type === 'checkbox') {
                    element.checked = currentSettings[key];
                } else {
                    element.value = currentSettings[key];
                }
            }
        });
    } catch (error) {
        console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
    }
}

// æ›´æ–°è®¾ç½®
function updateSetting(key, value) {
    currentSettings[key] = value;
}

// æ›´æ–°è¿æ¥çŠ¶æ€
function updateConnectionStatus(status) {
    const element = document.getElementById('connection-status');
    const footerElement = document.getElementById('connection-status-footer');
    
    if (element) {
        element.textContent = `åç«¯æœåŠ¡ï¼š${status}`;
    }
    
    if (footerElement) {
        footerElement.textContent = `åç«¯æœåŠ¡ï¼š${status}`;
    }
}

// æ›´æ–°çŠ¶æ€æ 
function updateStatusBar() {
    const timeElement = document.getElementById('current-time');
    if (timeElement) {
        const updateTime = () => {
            const now = new Date();
            timeElement.textContent = now.toLocaleString('zh-CN');
        };
        updateTime();
        setInterval(updateTime, 1000);
    }
}

// æ˜¾ç¤ºåŠ è½½çŠ¶æ€
function showLoading(text = 'æ­£åœ¨å¤„ç†...') {
    const overlay = document.getElementById('loading-overlay');
    const textElement = document.getElementById('loading-text');
    
    if (overlay) {
        overlay.style.display = 'flex';
    }
    
    if (textElement) {
        textElement.textContent = text;
    }
}

// éšè—åŠ è½½çŠ¶æ€
function hideLoading() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
}

// æ˜¾ç¤ºé€šçŸ¥
function showNotification(message, type = 'info') {
    const notificationContainer = document.getElementById('notification-container');
    if (!notificationContainer) {
        console.error('æ‰¾ä¸åˆ°é€šçŸ¥å®¹å™¨');
        return;
    }
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
        <span class="notification-message">${message}</span>
        <button class="notification-close" onclick="this.parentElement.remove()">Ã—</button>
    `;
    
    // æ·»åŠ åˆ°é€šçŸ¥å®¹å™¨
    notificationContainer.appendChild(notification);
    
    // æ·»åŠ è¿›å…¥åŠ¨ç”»
    setTimeout(() => {
        notification.classList.add('show');
    }, 10);
    
    // è‡ªåŠ¨ç§»é™¤
    setTimeout(() => {
        if (notification.parentElement) {
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 300);
        }
    }, 5000);
}

// æ˜¾ç¤ºå…³äºå¯¹è¯æ¡†
function showAboutDialog() {
    alert('ä¸­è¯å¤šç»„åˆ†å‡åŒ–åˆ†æå®¢æˆ·ç«¯ v1.0.0\n\nåŸºäºElectron + Flaskçš„è·¨å¹³å°æ¡Œé¢åº”ç”¨');
}

// å¯è§†åŒ–ç»“æœ
function visualizeResults(modelId) {
    showNotification('å›¾è¡¨åŠŸèƒ½å¼€å‘ä¸­...', 'info');
}

// å¯¼å‡ºè’™ç‰¹å¡æ´›é‡‡æ ·ç»“æœ
function exportMonteCarloResults(iterations) {
    showNotification('å¯¼å‡ºåŠŸèƒ½å¼€å‘ä¸­...', 'info');
}

// æ•°æ®ç®¡ç†ç›¸å…³å‡½æ•°
async function loadDataModels() {
    console.log('ğŸ“Š åŠ è½½æ•°æ®æ¨¡å‹åˆ—è¡¨...');
    const dataPreview = document.getElementById('data-preview');
    
    if (!dataPreview) {
        console.error('æ‰¾ä¸åˆ°æ•°æ®é¢„è§ˆå®¹å™¨');
        return;
    }
    
    try {
        showLoading('æ­£åœ¨åŠ è½½æ•°æ®æ¨¡å‹...');
        
        const response = await fetch(`${API_BASE_URL}/api/data-models/models`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Username': authManager.currentUser.username
            }
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.message || 'åŠ è½½æ•°æ®æ¨¡å‹å¤±è´¥');
        }
        
        displayDataModels(result.models);
        showNotification(`æˆåŠŸåŠ è½½ ${result.models.length} ä¸ªæ•°æ®æ¨¡å‹`, 'success');
        
    } catch (error) {
        console.error('âŒ åŠ è½½æ•°æ®æ¨¡å‹å¤±è´¥:', error);
        showNotification('åŠ è½½æ•°æ®æ¨¡å‹å¤±è´¥: ' + error.message, 'error');
        dataPreview.innerHTML = `<p>åŠ è½½å¤±è´¥: ${error.message}</p>`;
    } finally {
        hideLoading();
    }
}

function displayDataModels(models) {
    const dataPreview = document.getElementById('data-preview');
    
    if (!dataPreview) {
        console.error('æ‰¾ä¸åˆ°æ•°æ®é¢„è§ˆå®¹å™¨');
        return;
    }
    
    if (!models || models.length === 0) {
        dataPreview.innerHTML = '<p>æš‚æ— æ•°æ®æ¨¡å‹</p>';
        return;
    }
    
    // åˆ›å»ºè¡¨æ ¼
    const table = document.createElement('table');
    table.innerHTML = `
        <thead>
            <tr>
                <th>æ¨¡å‹åç§°</th>
                <th>æ¨¡å‹æè¿°</th>
                <th>åˆ›å»ºæ—¶é—´</th>
                <th>æ–‡ä»¶çŠ¶æ€</th>
                <th>æ“ä½œ</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    `;
    
    const tbody = table.querySelector('tbody');
    
    models.forEach(model => {
        const row = document.createElement('tr');
        const createdDate = new Date(model.created_at * 1000).toLocaleString('zh-CN');
        
        // ç”Ÿæˆæ–‡ä»¶çŠ¶æ€æ˜¾ç¤º
        const fileStatus = generateFileStatus(model.metadata);
        
        row.innerHTML = `
            <td><strong>${model.name}</strong></td>
            <td>${model.description || 'æš‚æ— æè¿°'}</td>
            <td>${createdDate}</td>
            <td>${fileStatus}</td>
            <td>
                <button class="btn-sm btn-primary" onclick="viewDataModel('${model.id}')">æŸ¥çœ‹</button>
                <button class="btn-sm btn-danger" onclick="deleteDataModel('${model.id}')">åˆ é™¤</button>
            </td>
        `;
        
        tbody.appendChild(row);
    });
    
    dataPreview.innerHTML = '';
    dataPreview.appendChild(table);
}

function generateFileStatus(metadata) {
    if (!metadata) return '<span class="status-unknown">æœªçŸ¥</span>';
    
    const status = [];
    
    if (metadata.has_csv_data) {
        status.push('<span class="status-ok">ğŸ“Š CSV</span>');
    } else {
        status.push('<span class="status-missing">âŒ CSV</span>');
    }
    
    if (metadata.has_regression_model) {
        status.push('<span class="status-ok">ğŸ“ˆ å›å½’</span>');
    } else {
        status.push('<span class="status-missing">âŒ å›å½’</span>');
    }
    
    if (metadata.has_monte_carlo_results) {
        status.push('<span class="status-ok">ğŸ² è’™ç‰¹å¡æ´›</span>');
    } else {
        status.push('<span class="status-missing">âŒ è’™ç‰¹å¡æ´›</span>');
    }
    
    return status.join(' ');
}

// ä¸ºè’™ç‰¹å¡æ´›é‡‡æ ·åŠ è½½æ•°æ®æ¨¡å‹åˆ—è¡¨
async function loadDataModelsForMonteCarlo() {
    console.log('ğŸ“Š ä¸ºè’™ç‰¹å¡æ´›é‡‡æ ·åŠ è½½æ•°æ®æ¨¡å‹åˆ—è¡¨...');
    const dataModelSelect = document.getElementById('mc-data-model');
    
    if (!dataModelSelect) {
        console.error('æ‰¾ä¸åˆ°æ•°æ®æ¨¡å‹é€‰æ‹©æ¡†');
        return;
    }
    
    try {
        const response = await fetch(`${API_BASE_URL}/api/data-models/models`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Username': authManager.currentUser.username
            }
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.message || 'åŠ è½½æ•°æ®æ¨¡å‹å¤±è´¥');
        }
        
        // è¿‡æ»¤å‡ºæœ‰ç¬¦å·å›å½’æ¨¡å‹çš„æ•°æ®æ¨¡å‹
        const modelsWithRegression = result.models.filter(model => 
            model.metadata && model.metadata.has_regression_model
        );
        
        // æ›´æ–°é€‰æ‹©æ¡†
        dataModelSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ•°æ®æ¨¡å‹</option>';
        modelsWithRegression.forEach(model => {
            const option = document.createElement('option');
            option.value = model.id;
            option.textContent = `${model.name} (${model.target_column})`;
            dataModelSelect.appendChild(option);
        });
        
        console.log(`âœ… åŠ è½½äº† ${modelsWithRegression.length} ä¸ªå¯ç”¨çš„æ•°æ®æ¨¡å‹`);
        
    } catch (error) {
        console.error('âŒ åŠ è½½æ•°æ®æ¨¡å‹å¤±è´¥:', error);
        showNotification('åŠ è½½æ•°æ®æ¨¡å‹å¤±è´¥: ' + error.message, 'error');
        dataModelSelect.innerHTML = '<option value="">åŠ è½½å¤±è´¥</option>';
    }
}

async function viewDataModel(modelId) {
    console.log(`ğŸ“Š æŸ¥çœ‹æ•°æ®æ¨¡å‹: ${modelId}`);
    
    try {
        showLoading('æ­£åœ¨åŠ è½½æ¨¡å‹è¯¦æƒ…...');
        
        const response = await fetch(`${API_BASE_URL}/api/data-models/models/${modelId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Username': authManager.currentUser.username
            }
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.message || 'åŠ è½½æ¨¡å‹è¯¦æƒ…å¤±è´¥');
        }
        
        showDataModelDetails(result.model);
        
    } catch (error) {
        console.error('âŒ æŸ¥çœ‹æ•°æ®æ¨¡å‹å¤±è´¥:', error);
        showNotification('æŸ¥çœ‹æ•°æ®æ¨¡å‹å¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
    }
}

function showDataModelDetails(model) {
    // åˆ›å»ºæ¨¡æ€æ¡†æ˜¾ç¤ºæ¨¡å‹è¯¦æƒ…ï¼ˆç¾åŒ–ç‰ˆï¼Œä»…ä½œç”¨äºæœ¬å¼¹çª—ï¼‰
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    const featureTags = (model.feature_columns && model.feature_columns.length)
        ? model.feature_columns.map(col => `<span class="tag">${col}</span>`).join('')
        : '<span class="text-muted">æ— </span>';
    const csvStatus = model.metadata && model.metadata.has_csv_data ? '<span class="status-ok">ğŸ“Š CSV</span>' : '<span class="status-missing">âŒ CSV</span>';
    const regStatus = model.metadata && model.metadata.has_regression_model ? '<span class="status-ok">ğŸ“ˆ å›å½’</span>' : '<span class="status-missing">âŒ å›å½’</span>';
    const mcStatus = model.metadata && model.metadata.has_monte_carlo_results ? '<span class="status-ok">ğŸ² è’™ç‰¹å¡æ´›</span>' : '<span class="status-missing">âŒ è’™ç‰¹å¡æ´›</span>';
    
    modal.innerHTML = `
        <div class="modal-content model-details">
            <div class="modal-header">
                <h3>æ•°æ®æ¨¡å‹è¯¦æƒ…</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">Ã—</button>
            </div>
            <div class="modal-body">
                <section class="details-section">
                    <div class="section-title">åŸºæœ¬ä¿¡æ¯</div>
                    <div class="info-grid">
                        <div class="info-item"><div class="info-label">åç§°</div><div class="info-value">${model.name}</div></div>
                        <div class="info-item"><div class="info-label">ç›®æ ‡å˜é‡</div><div class="info-value">${model.target_column || '-'}</div></div>
                        <div class="info-item info-span-2"><div class="info-label">æè¿°</div><div class="info-value">${model.description || '-'}</div></div>
                        <div class="info-item info-span-2"><div class="info-label">ç‰¹å¾å˜é‡</div><div class="info-value tag-list">${featureTags}</div></div>
                        <div class="info-item"><div class="info-label">åˆ›å»ºæ—¶é—´</div><div class="info-value">${model.created_at ? new Date(model.created_at * 1000).toLocaleString('zh-CN') : '-'}</div></div>
                        <div class="info-item"><div class="info-label">çŠ¶æ€</div><div class="info-value">${model.status === 'active' ? 'æ´»è·ƒ' : 'éæ´»è·ƒ'}</div></div>
                    </div>
                </section>
                
                <section class="details-section">
                    <div class="section-title">æ–‡ä»¶çŠ¶æ€</div>
                    <div class="status-chips">
                        ${csvStatus} ${regStatus} ${mcStatus}
                    </div>
                    <div class="file-actions">
                        ${model.metadata && model.metadata.has_csv_data 
                            ? `<button class="btn-sm btn-primary" onclick="viewDataModelFile('${model.id}', 'csv_data')">æŸ¥çœ‹CSVæ•°æ®</button>` 
                            : '<span class="text-muted">CSVæ•°æ®æ–‡ä»¶ä¸å­˜åœ¨</span>'}
                        ${model.metadata && model.metadata.has_regression_model 
                            ? `<button class="btn-sm btn-primary" onclick="viewDataModelFile('${model.id}', 'regression_model')">æŸ¥çœ‹å›å½’æ¨¡å‹</button>` 
                            : '<span class="text-muted">å›å½’æ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨</span>'}
                        ${model.metadata && model.metadata.has_monte_carlo_results 
                            ? `<button class="btn-sm btn-primary" onclick="viewDataModelFile('${model.id}', 'monte_carlo_results')">æŸ¥çœ‹è’™ç‰¹å¡æ´›ç»“æœ</button>` 
                            : '<span class="text-muted">è’™ç‰¹å¡æ´›ç»“æœæ–‡ä»¶ä¸å­˜åœ¨</span>'}
                    </div>
                </section>
                
                <section class="details-section advanced-info">
                    <div class="section-title-row">
                        <div class="section-title">é«˜çº§ä¿¡æ¯</div>
                        <button class="btn-secondary btn-compact section-collapse-btn" data-collapsed="true">å±•å¼€</button>
                    </div>
                    <div class="advanced-content" style="display:none;">
                        <div class="info-grid">
                            ${model.data_source ? `<div class="info-item"><div class="info-label">æ•°æ®æ¥æº</div><div class="info-value">${model.data_source}</div></div>` : ''}
                            ${model.analysis_type ? `<div class="info-item"><div class="info-label">åˆ†æç±»å‹</div><div class="info-value">${model.analysis_type}</div></div>` : ''}
                            ${model.created_by ? `<div class="info-item"><div class="info-label">åˆ›å»ºäºº</div><div class="info-value">${model.created_by}</div></div>` : ''}
                            ${model.updated_at ? `<div class="info-item"><div class="info-label">æ›´æ–°æ—¶é—´</div><div class="info-value">${new Date(model.updated_at * 1000).toLocaleString('zh-CN')}</div></div>` : ''}
                            ${model.data_files && model.data_files.csv_data ? `<div class="info-item info-span-2"><div class="info-label">CSVæ–‡ä»¶</div><div class="info-value">${model.data_files.csv_data}</div></div>` : ''}
                            ${model.data_files && model.data_files.regression_model ? `<div class="info-item info-span-2"><div class="info-label">å›å½’æ¨¡å‹æ–‡ä»¶</div><div class="info-value">${model.data_files.regression_model}</div></div>` : ''}
                            ${model.data_files && model.data_files.monte_carlo_results ? `<div class="info-item info-span-2"><div class="info-label">è’™ç‰¹å¡æ´›ç»“æœæ–‡ä»¶</div><div class="info-value">${model.data_files.monte_carlo_results}</div></div>` : ''}
                        </div>
                        <div class="raw-toggle">
                            <button class="btn-secondary btn-compact raw-json-toggle" data-mode="hidden">æ˜¾ç¤ºåŸå§‹æ•°æ®</button>
                            <button class="btn-secondary btn-compact copy-json-btn">å¤åˆ¶JSON</button>
                        </div>
                        <div class="meta-box raw-json" style="display:none;"><pre>${JSON.stringify({
                            id: model.id,
                            data_source: model.data_source,
                            analysis_type: model.analysis_type,
                            created_by: model.created_by,
                            created_at: model.created_at,
                            updated_at: model.updated_at,
                            data_files: model.data_files || {},
                            metadata: model.metadata || {}
                        }, null, 2)}</pre></div>
                    </div>
                </section>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="this.closest('.modal-overlay').remove()">å…³é—­</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // é«˜çº§ä¿¡æ¯æŠ˜å /å±•å¼€ä¸åŸå§‹JSONåˆ‡æ¢
    const collapseBtn = modal.querySelector('.section-collapse-btn');
    const advContent = modal.querySelector('.advanced-content');
    const rawToggleBtn = modal.querySelector('.raw-json-toggle');
    const rawBox = modal.querySelector('.raw-json');
    const copyBtn = modal.querySelector('.copy-json-btn');
    
    collapseBtn?.addEventListener('click', () => {
        const collapsed = collapseBtn.getAttribute('data-collapsed') === 'true';
        if (collapsed) {
            advContent.style.display = '';
            collapseBtn.textContent = 'æ”¶èµ·';
            collapseBtn.setAttribute('data-collapsed', 'false');
        } else {
            advContent.style.display = 'none';
            collapseBtn.textContent = 'å±•å¼€';
            collapseBtn.setAttribute('data-collapsed', 'true');
        }
    });
    
    rawToggleBtn?.addEventListener('click', () => {
        const mode = rawToggleBtn.getAttribute('data-mode') || 'hidden';
        if (mode === 'hidden') {
            rawBox.style.display = '';
            rawToggleBtn.textContent = 'éšè—åŸå§‹æ•°æ®';
            rawToggleBtn.setAttribute('data-mode', 'shown');
        } else {
            rawBox.style.display = 'none';
            rawToggleBtn.textContent = 'æ˜¾ç¤ºåŸå§‹æ•°æ®';
            rawToggleBtn.setAttribute('data-mode', 'hidden');
        }
    });
    
    copyBtn?.addEventListener('click', async () => {
        try {
            const text = rawBox?.innerText || '';
            if (navigator.clipboard && text) {
                await navigator.clipboard.writeText(text);
                showNotification('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
            } else {
                throw new Error('Clipboard API ä¸å¯ç”¨');
            }
        } catch (e) {
            showNotification('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬å¤åˆ¶', 'warning');
        }
    });
}

async function deleteDataModel(modelId) {
    console.log(`ğŸ—‘ï¸ åˆ é™¤æ•°æ®æ¨¡å‹: ${modelId}`);
    
    // ä½¿ç”¨ç»Ÿä¸€çš„ä¸»é¢˜åŒ–ç¡®è®¤å¼¹çª—
    if (!(await authManager.showConfirmDialog('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ•°æ®æ¨¡å‹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚'))) {
        return;
    }
    
    try {
        showLoading('æ­£åœ¨åˆ é™¤æ•°æ®æ¨¡å‹...');
        
        const response = await fetch(`${API_BASE_URL}/api/data-models/models/${modelId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-Username': authManager.currentUser.username
            }
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.message || 'åˆ é™¤æ•°æ®æ¨¡å‹å¤±è´¥');
        }
        
        showNotification('æ•°æ®æ¨¡å‹åˆ é™¤æˆåŠŸ', 'success');
        
        // é‡æ–°åŠ è½½æ•°æ®æ¨¡å‹åˆ—è¡¨
        setTimeout(() => {
            loadDataModels();
        }, 500);
        
    } catch (error) {
        console.error('âŒ åˆ é™¤æ•°æ®æ¨¡å‹å¤±è´¥:', error);
        showNotification('åˆ é™¤æ•°æ®æ¨¡å‹å¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
    }
}

// æŸ¥çœ‹æ•°æ®æ¨¡å‹æ–‡ä»¶
async function viewDataModelFile(modelId, fileType) {
    console.log(`ğŸ“„ æŸ¥çœ‹æ•°æ®æ¨¡å‹æ–‡ä»¶: ${modelId}, ç±»å‹: ${fileType}`);
    
    try {
        showLoading('æ­£åœ¨åŠ è½½æ–‡ä»¶å†…å®¹...');
        
        const response = await fetch(`${API_BASE_URL}/api/data-models/models/${modelId}/files/${fileType}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Username': authManager.currentUser.username
            }
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.message || 'åŠ è½½æ–‡ä»¶å¤±è´¥');
        }
        
        showFileContent(result.content, result.filename, fileType);
        
    } catch (error) {
        console.error('âŒ æŸ¥çœ‹æ•°æ®æ¨¡å‹æ–‡ä»¶å¤±è´¥:', error);
        showNotification('æŸ¥çœ‹æ–‡ä»¶å¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
    }
}

// æ˜¾ç¤ºæ–‡ä»¶å†…å®¹ï¼ˆæ”¯æŒ"ç¾åŒ–è§†å›¾/åŸå§‹å†…å®¹"åˆ‡æ¢ï¼‰
function showFileContent(content, filename, fileType) {
    const fileTypeNames = {
        'csv_data': 'CSVæ•°æ®æ–‡ä»¶',
        'regression_model': 'ç¬¦å·å›å½’æ¨¡å‹',
        'monte_carlo_results': 'è’™ç‰¹å¡æ´›åˆ†æç»“æœ'
    };

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="modal-content modal-large">
            <div class="modal-header">
                <h3>${fileTypeNames[fileType] || 'æ–‡ä»¶å†…å®¹'}</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="file-info">
                    <p><strong>æ–‡ä»¶å:</strong> ${filename}</p>
                    <p><strong>æ–‡ä»¶ç±»å‹:</strong> ${fileTypeNames[fileType] || '-'}</p>
                </div>
                <div class="view-toggle">
                    <button class="btn-secondary toggle-view-btn" data-mode="beautified">åˆ‡æ¢ä¸ºåŸå§‹å†…å®¹</button>
                </div>
                <div class="beautified-view"></div>
                <div class="file-content raw-view" style="display:none;">
                    <pre>${content}</pre>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="this.closest('.modal-overlay').remove()">å…³é—­</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // æ¸²æŸ“ç¾åŒ–è§†å›¾
    try {
        renderBeautifiedFileContent(modal.querySelector('.beautified-view'), content, filename, fileType);
    } catch (e) {
        // è§£æå¤±è´¥åˆ™é»˜è®¤æ˜¾ç¤ºåŸå§‹å†…å®¹
        const toggleBtn = modal.querySelector('.toggle-view-btn');
        const beautified = modal.querySelector('.beautified-view');
        const raw = modal.querySelector('.raw-view');
        if (beautified) beautified.style.display = 'none';
        if (raw) raw.style.display = '';
        if (toggleBtn) toggleBtn.textContent = 'åˆ‡æ¢ä¸ºæ¦‚è§ˆè§†å›¾';
        if (toggleBtn) toggleBtn.dataset.mode = 'raw';
    }

    // åˆ‡æ¢æŒ‰é’®äº‹ä»¶
    const toggleBtn = modal.querySelector('.toggle-view-btn');
    toggleBtn?.addEventListener('click', () => {
        const mode = toggleBtn.dataset.mode || 'beautified';
        const beautified = modal.querySelector('.beautified-view');
        const raw = modal.querySelector('.raw-view');
        if (mode === 'beautified') {
            // åˆ‡æ¢åˆ°åŸå§‹
            if (beautified) beautified.style.display = 'none';
            if (raw) raw.style.display = '';
            toggleBtn.textContent = 'åˆ‡æ¢ä¸ºæ¦‚è§ˆè§†å›¾';
            toggleBtn.dataset.mode = 'raw';
        } else {
            // åˆ‡æ¢åˆ°ç¾åŒ–
            if (beautified && beautified.children.length === 0) {
                // å†æ¬¡æ¸²æŸ“å…œåº•
                try { renderBeautifiedFileContent(beautified, content, filename, fileType); } catch (_) {}
            }
            if (beautified) beautified.style.display = '';
            if (raw) raw.style.display = 'none';
            toggleBtn.textContent = 'åˆ‡æ¢ä¸ºåŸå§‹å†…å®¹';
            toggleBtn.dataset.mode = 'beautified';
        }
    });
}

// æ¸²æŸ“ç¾åŒ–è§†å›¾
function renderBeautifiedFileContent(container, content, filename, fileType) {
    if (!container) return;
    if (fileType === 'csv_data') {
        // CSV ç¾åŒ–ï¼šå±•ç¤ºåŸºç¡€ç»Ÿè®¡ä¸å‰è‹¥å¹²è¡Œé¢„è§ˆ
        const parsed = parseCSV(content || '');
        const headers = parsed.headers || [];
        const rows = parsed.data || [];
        const previewRows = rows.slice(0, 10);
        const html = `
            <div class="beautified-csv">
                <div class="metric-cards">
                    <div class="metric-card"><div class="metric-label">æ–‡ä»¶å</div><div class="metric-value">${filename || '-'}</div></div>
                    <div class="metric-card"><div class="metric-label">è¡Œæ•°</div><div class="metric-value">${parsed.rows || 0}</div></div>
                    <div class="metric-card"><div class="metric-label">åˆ—æ•°</div><div class="metric-value">${parsed.columns || 0}</div></div>
                </div>
                <div class="csv-table-container">
                    <table class="csv-table">
                        <thead>
                            <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                        </thead>
                        <tbody>
                            ${previewRows.map(row => `<tr>${headers.map(h => `<td>${row[h] ?? ''}</td>`).join('')}</tr>`).join('')}
                        </tbody>
                    </table>
                </div>
                ${rows.length > previewRows.length ? `<div class="csv-more">ä»…å±•ç¤ºå‰ ${previewRows.length} è¡Œï¼Œå…± ${rows.length} è¡Œ</div>` : ''}
            </div>
        `;
        container.innerHTML = html;
        return;
    }

    if (fileType === 'regression_model') {
        const json = JSON.parse(content || '{}');
        const featureImportance = Array.isArray(json.feature_importance) ? json.feature_importance.slice() : [];
        featureImportance.sort((a, b) => (b.importance || 0) - (a.importance || 0));
        const html = `
            <div class="beautified-json">
                <div class="metric-cards">
                    <div class="metric-card"><div class="metric-label">ç›®æ ‡å˜é‡</div><div class="metric-value">${json.target_column || '-'}</div></div>
                    <div class="metric-card"><div class="metric-label">RÂ²</div><div class="metric-value">${json.r2 ?? '-'}</div></div>
                    <div class="metric-card"><div class="metric-label">MSE</div><div class="metric-value">${json.mse ?? '-'}</div></div>
                    <div class="metric-card"><div class="metric-label">å¤æ‚åº¦</div><div class="metric-value">${json.model_complexity ?? '-'}</div></div>
                </div>
                ${json.expression ? `<div class="expression-box"><div class="expression-label">æ¨¡å‹è¡¨è¾¾å¼</div><div class="expression-value">${json.expression}</div></div>` : ''}
                ${featureImportance.length ? `
                <div class="section-subtitle">ç‰¹å¾é‡è¦æ€§</div>
                <div class="importance-table">
                    ${featureImportance.map(item => `
                        <div class="importance-row">
                            <div class="imp-name">${item.feature}</div>
                            <div class="imp-bar"><span style="width:${Math.min(100, Math.round((item.importance || 0) * 100))}%"></span></div>
                            <div class="imp-value">${(item.importance ?? 0).toFixed(3)}</div>
                        </div>
                    `).join('')}
                </div>` : ''}
            </div>
        `;
        container.innerHTML = html;
        return;
    }

    if (fileType === 'monte_carlo_results') {
        // æ—¢æ”¯æŒ JSONï¼Œä¹Ÿæ”¯æŒ .txt æ–‡æœ¬æŠ¥å‘Š
        let json = null;
        try { json = JSON.parse(content || '{}'); } catch (_) { json = null; }

        if (json && (json.target_statistics || json.feature_importance || json.simulations)) {
            const stats = json.target_statistics || {};
            const cis = json.confidence_intervals || {};
            const fi = Array.isArray(json.feature_importance) ? json.feature_importance.slice() : [];
            fi.sort((a, b) => (b.importance || 0) - (a.importance || 0));
            const top = fi.slice(0, 10);
            const sims = Array.isArray(json.simulations) ? json.simulations : [];
            const html = `
                <div class="beautified-json">
                    <div class="metric-cards">
                        <div class="metric-card"><div class="metric-label">å‡å€¼</div><div class="metric-value">${fmtNum(stats.mean)}</div></div>
                        <div class="metric-card"><div class="metric-label">æ ‡å‡†å·®</div><div class="metric-value">${fmtNum(stats.std)}</div></div>
                        <div class="metric-card"><div class="metric-label">æœ€å°å€¼</div><div class="metric-value">${fmtNum(stats.min)}</div></div>
                        <div class="metric-card"><div class="metric-label">æœ€å¤§å€¼</div><div class="metric-value">${fmtNum(stats.max)}</div></div>
                    </div>
                    <div class="section-subtitle">ç½®ä¿¡åŒºé—´</div>
                    <div class="ci-grid">
                        ${Object.keys(cis).map(k => {
                            const c = cis[k] || {}; return `<div class=\"ci-item\"><div class=\"ci-label\">${k.toUpperCase()}</div><div class=\"ci-value\">${fmtNum(c.lower)} ~ ${fmtNum(c.upper)}</div></div>`;
                        }).join('')}
                    </div>
                    ${top.length ? `
                    <div class="section-subtitle">ç‰¹å¾é‡è¦æ€§ï¼ˆTop ${top.length}ï¼‰</div>
                    <div class="importance-table">
                        ${top.map(item => `
                            <div class="importance-row">
                                <div class="imp-name">${item.feature}</div>
                                <div class="imp-bar"><span style="width:${Math.min(100, Math.round((item.importance || 0) * 100))}%"></span></div>
                                <div class="imp-value">${(item.importance ?? 0).toFixed(3)}</div>
                            </div>
                        `).join('')}
                    </div>` : ''}
                    ${sims.length ? `
                    <div class="section-subtitle">æ¨¡æ‹Ÿæ ·æœ¬ï¼ˆå‰5æ¡ï¼‰</div>
                    <div class="csv-table-container">
                        <table class="csv-table">
                            <thead><tr><th>#</th><th>ç‰¹å¾ç»´åº¦</th><th>ç›®æ ‡å€¼</th></tr></thead>
                            <tbody>
                                ${sims.slice(0, 5).map(s => `<tr><td>${s.iteration ?? '-'}</td><td>${Array.isArray(s.features) ? s.features.length : '-'}</td><td>${fmtNum(s.target)}</td></tr>`).join('')}
                            </tbody>
                        </table>
                    </div>` : ''}
                </div>
            `;
            container.innerHTML = html;
            return;
        }

        // æ–‡æœ¬æŠ¥å‘Šè§£æ
        const parsed = parseMonteCarloText(content || '');
        if (parsed) {
            const html = `
                <div class="beautified-json">
                    <div class="metric-cards">
                        ${parsed.target !== undefined ? `<div class=\"metric-card\"><div class=\"metric-label\">ç›®æ ‡è¯æ•ˆ</div><div class=\"metric-value\">${parsed.target}</div></div>` : ''}
                        ${parsed.samples !== undefined ? `<div class=\"metric-card\"><div class=\"metric-label\">é‡‡æ ·æ¬¡æ•°</div><div class=\"metric-value\">${parsed.samples}</div></div>` : ''}
                        ${parsed.valid !== undefined ? `<div class=\"metric-card\"><div class=\"metric-label\">æœ‰æ•ˆæ ·æœ¬</div><div class=\"metric-value\">${parsed.valid}</div></div>` : ''}
                        ${parsed.successRate !== undefined ? `<div class=\"metric-card\"><div class=\"metric-label\">æˆåŠŸç‡</div><div class=\"metric-value\">${parsed.successRate}%</div></div>` : ''}
                    </div>
                    ${parsed.recommendations && parsed.recommendations.length ? `
                    <div class="section-subtitle">æ¨èæ–¹æ¡ˆï¼ˆå‰${Math.min(10, parsed.recommendations.length)}æ¡ï¼‰</div>
                    <div class="csv-table-container">
                        <table class="csv-table">
                            <thead><tr><th>#</th><th>é¢„æœŸè¯æ•ˆ</th><th>é…æ¯”æ–¹æ¡ˆ</th></tr></thead>
                            <tbody>
                                ${parsed.recommendations.slice(0, 10).map((r, idx) => `<tr><td>${idx + 1}</td><td>${r.effect}</td><td>${r.recipe}</td></tr>`).join('')}
                            </tbody>
                        </table>
                    </div>` : ''}
                </div>
            `;
            container.innerHTML = html;
            return;
        }

        // è‹¥æ— æ³•è§£æï¼Œåˆ™æŠ›å‡ºä»¥è§¦å‘åŸå§‹å†…å®¹å›é€€
        throw new Error('Unsupported monte carlo text format');
    }

    // é»˜è®¤ï¼šæ²¡æœ‰ç¾åŒ–
    container.innerHTML = `<div class="text-muted">è¯¥æ–‡ä»¶ç±»å‹æš‚ä¸æ”¯æŒç¾åŒ–è§†å›¾ï¼Œå¯åˆ‡æ¢æŸ¥çœ‹åŸå§‹å†…å®¹</div>`;
}

function fmtNum(v) {
    if (typeof v !== 'number') return '-';
    const s = Math.abs(v) >= 1000 ? v.toFixed(0) : Math.abs(v) >= 1 ? v.toFixed(3) : v.toPrecision(3);
    return s;
}

// è§£æè’™ç‰¹å¡æ´› .txt æ–‡æœ¬æŠ¥å‘Šï¼Œè¿”å›ç®€è¦ç»“æ„
function parseMonteCarloText(text) {
    if (!text || typeof text !== 'string') return null;
    const clean = text.replace(/\r/g, '');
    const lines = clean.split('\n').map(l => l.trim()).filter(Boolean);
    if (!lines.length) return null;

    const result = {};
    // ç›®æ ‡è¯æ•ˆã€é‡‡æ ·æ¬¡æ•°ã€æœ‰æ•ˆæ ·æœ¬ã€æˆåŠŸç‡
    const targetMatch = clean.match(/ç›®æ ‡è¯æ•ˆ[:ï¼š]\s*([\d.]+)/);
    if (targetMatch) result.target = Number(targetMatch[1]);
    const samplesMatch = clean.match(/é‡‡æ ·æ¬¡æ•°[:ï¼š]\s*([\d,]+)/);
    if (samplesMatch) result.samples = Number(samplesMatch[1].replace(/,/g, ''));
    const validMatch = clean.match(/æœ‰æ•ˆæ ·æœ¬[:ï¼š]\s*([\d,]+)/);
    if (validMatch) result.valid = Number(validMatch[1].replace(/,/g, ''));
    const successMatch = clean.match(/æˆåŠŸç‡[:ï¼š]\s*([\d.]+)%/);
    if (successMatch) result.successRate = Number(successMatch[1]);

    // æ¨èæ–¹æ¡ˆï¼ˆ"æ¨èæ–¹æ¡ˆ 1: ...ï¼Œé¢„æœŸè¯æ•ˆ: 22.5"é£æ ¼ï¼‰
    const recs = [];
    const recRe = /æ¨èæ–¹æ¡ˆ\s*\d+\s*[:ï¼š]\s*([^ï¼Œ,]+(?:[ï¼Œ,].*?)?)\s*[ï¼Œ,]\s*é¢„æœŸè¯æ•ˆ[:ï¼š]\s*([\d.]+)/g;
    let m;
    while ((m = recRe.exec(clean)) !== null) {
        const recipe = (m[1] || '').trim();
        const effect = Number(m[2]);
        if (recipe) recs.push({ recipe, effect });
    }
    if (recs.length) result.recommendations = recs;

    // å¦‚æœè‡³å°‘è§£æå‡ºä¸€é¡¹å…³é”®æ•°æ®ï¼Œåˆ™è®¤ä¸ºæœ‰æ•ˆ
    if (result.target !== undefined || result.samples !== undefined || (result.recommendations && result.recommendations.length)) {
        return result;
    }
    return null;
}

// æ•°æ®ç®¡ç†é¡µé¢äº‹ä»¶ç›‘å¬å™¨
function setupDataManagementListeners() {
    const importDataBtn = document.getElementById('import-data-btn');
    const exportDataBtn = document.getElementById('export-data-btn');
    const clearDataBtn = document.getElementById('clear-data-btn');
    
    if (importDataBtn) {
        importDataBtn.addEventListener('click', () => {
            showNotification('å¯¼å…¥åŠŸèƒ½å¼€å‘ä¸­...', 'info');
        });
    }
    
    if (exportDataBtn) {
        exportDataBtn.addEventListener('click', () => {
            showNotification('å¯¼å‡ºåŠŸèƒ½å¼€å‘ä¸­...', 'info');
        });
    }
    
    if (clearDataBtn) {
        clearDataBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®æ¨¡å‹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                showNotification('æ¸…ç©ºåŠŸèƒ½å¼€å‘ä¸­...', 'info');
            }
        });
    }
}

// å…¨å±€å‡½æ•°ï¼ˆä¾›HTMLè°ƒç”¨ï¼‰
window.switchTab = switchTab;
window.startRegression = startRegression;
window.startMonteCarlo = startMonteCarlo;
window.importData = importData;
window.exportResults = exportResults;
window.testBackendConnection = testBackendConnection;
window.saveSettings = saveSettings;
window.loadDataModels = loadDataModels;
window.viewDataModel = viewDataModel;
window.deleteDataModel = deleteDataModel; 
window.viewDataModelFile = viewDataModelFile;