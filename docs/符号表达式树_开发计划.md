## 目标

在不新增第三方前端依赖的前提下，实现“符号表达式树”功能：
- 依据回归表达式字符串解析为 AST；
- 计算每个节点/子树对目标变量的影响力（权重）并着色；
- 在 `#expression-tree-canvas` 中以 SVG 渲染（父节点=圆形运算符，叶子=矩形常数/变量项）；
- 支持右键菜单删除节点/子树并联动更新表达式、公式渲染与颜色；
- 与现有“符号表达式树”页面布局联动（右上公式、左侧指标、下方特征权重已就绪）。

数据入口：`/api/symbolic-regression/expression-tree/summary` 或最近一次回归结果（已在 `renderExpressionTreePage()` 中获取）。

---

## 一、拟新增文件与改动点（仅前端）

1) 新增 `frontend/scripts/exprTree.js`
- 导出公共方法：
  - `parseExpressionToAst(expression)`
  - `normalizeAst(ast)`
  - `computeWeights(ast, options)`
  - `layoutTree(ast, viewportW, metrics)`
  - `renderSvgTree(containerEl, ast, options)`
  - `attachInteractions(containerEl, ast, callbacks)`
  - `astToExpression(ast)`
  - `formatNumberSci(x)`、`weightToColor(weight, scale)`

2) 在 `frontend/index.html`
- 末尾 `<script>` 引入 `scripts/exprTree.js`（在 `scripts/renderer.js` 之后）。

3) 在 `frontend/scripts/renderer.js`
- `renderExpressionTreePage()` 的成功分支追加：
  - `displayExpressionTreeSummary(summary)` 已存在；
  - 新增 `renderExpressionTreeSVG(summary)`：解析表达式→建树→计算权重→布局→渲染→绑定交互。
  - 右键删除后回写：更新 AST→重算权重/布局→重绘；同时 `astToExpression(ast)` 推送给 `displayExpressionTreeSummary` 以刷新右上公式。

4) 在 `frontend/styles/main.css`
- 追加极少量样式：树容器滚动、右键菜单样式、选中高亮描边等。

---

## 二、数据契约与示例

输入 `summary` 对象（由现有 API/模拟返回）：
```json
{
  "expression": "QA * 0.5 + NCGA * 0.3 + 0.1",
  "target_variable": "Y",
  "constants": {"c_0": 0.5},
  "feature_importance": [{"feature":"QA","importance":0.8}],
  "detailed_metrics": {"r2": 0.92}
}
```

容器：`#expression-tree-canvas`（宽高自适应卡片）。

---

## 三、AST 设计与类型

```ts
type Operator = 'add' | 'sub' | 'mul' | 'div';
type NodeKind = 'operator' | 'constant' | 'variable';

interface ExprNode {
  id: string;                 // 稳定ID（如 nanoid 或自增）
  kind: NodeKind;
  op?: Operator;              // operator 节点必有
  value?: number | string;    // constant: number; variable: 变量名
  coefficient?: number;       // variable 的常系数（如 0.5 * QA）
  children: ExprNode[];       // 仅 operator 有
  subExpr?: string;           // 子表达式字符串缓存
  weight?: number;            // 权重
  color?: string;             // 颜色（由 weightToColor 映射）
  layout?: { x: number; y: number; w: number; h: number };
}
```

---

## 四、解析器（Shunting-yard → AST）

支持：数字（含负号）、变量名、括号、`+ - * /`。

步骤：
1. 词法分析：
   - token 类型：`NUMBER`、`IDENT`、`LPAREN`、`RPAREN`、`OP(+ - * /)`。
   - 处理一元负号：在表达式开头或在 `(`、运算符后出现的 `-` 视作一元负号，转换为 `-1 * term`。
2. 中缀→后缀（逆波兰），优先级：`* /` > `+ -`，左结合。
3. 后缀→AST：
   - 碰到 `NUMBER` → 常数叶子；`IDENT` → 变量叶子；`OP` → 出栈 2 个子树生成运算符父节点。
4. 规范化 `normalizeAst`：
   - 将 `mul(const, var)` 或 `mul(var, const)` 下沉为变量叶子的 `coefficient`；
   - 连续同类运算如 `a + (b + c)` 扁平化为 `add[a,b,c]`；
   - 清理无用常数（可延后到 V2）。

---

## 五、权重计算与颜色映射

V1（首版，系数驱动，零依赖）：
- 变量叶子权重：`coefficient || 1`；常数叶子权重：`0`。
- 运算符：聚合子权重
  - `add`: 所有子权重求和；
  - `sub`: 左 - 右；
  - `mul`: 若存在常数系数，乘到子叶子权重再聚合；否则取子权重和；
  - `div`: 分子权重 − 分母权重（简化，V2 再精化）。
- 颜色：
  - 归一化 `t = clamp(|w| / P95(|所有节点w|), 0, 1)`；
  - `w>0` 使用绿色带：`hsl(145,60%, L)`；`w<0` 使用红色带：`hsl(0,65%, L)`；
  - `L = 95% - 60% * t`；`w=0` 为白色填充、深灰描边。

V2（可选增强）：
- 在样本均值点上进行数值微分近似，或用 SHAP-like 的简单增量，获得更准确的子树影响。

---

## 六、布局算法（简化 tidy-tree）

常量：
- 节点尺寸：运算符直径 80；叶子矩形 110×56；
- 间距：水平 40，垂直 120（随容器宽度自适应）；

过程：
1. 自底向上计算每个子树的宽度 `subW = max(nodeMinW, sum(child.subW) + (n-1)*hGap)`。
2. 自顶向下分配 `x`：
   - 父节点中心位于子区间的几何中心；
   - 子节点依次排布，累积偏移。
3. `y = depth * vGap`。
4. 计算整体边界，设置 `<svg viewBox>` 以自适应缩放。

---

## 七、SVG 渲染

1. 生成 `<svg>` 与 `<g>` 容器；
2. 先画连线：从父到子（直线或贝塞尔弧线）；
3. 再画节点：
   - 运算符：圆形，填充为 `color`，文本：`Addition/Multiplication/...`（或中文切换）。
   - 变量：圆角矩形，主文本=变量名；副文本=中文名（tooltip 中显示，来自 `COMPONENT_NAMES`）。
   - 常数：矩形，文本=科学计数法（3~4 有效位）。
4. Tooltip：`<title>` 或自定义浮层，含 子表达式、权重、中文名。
5. 交互数据绑定：`data-id` 对应 `node.id`。

---

## 八、交互与变更传播

右键菜单（`contextmenu`）：
- 选项：
  - 删除该节点（对叶子/安全的运算符开放）；
  - 删除整棵子树（任意节点）；
- 规则化简：
  - `Addition/Subtraction`：删除某子树后，若无剩余子 → 常数 0；
  - `Multiplication`：删除某因子后，若无剩余因子 → 常数 1；
  - `Division`：禁止直接删除分母；允许“删除整棵子树”（分母→1）。
- 撤销：维护一个最近快照栈 `undoStack`（最多 10）。

传播链：
`AST 变化 → recompute weights → layout → rerender → astToExpression(ast) → displayExpressionTreeSummary()` 刷新右上公式（MathJax 自动重排）。

---

## 九、核心函数草案（伪代码）

```js
function renderExpressionTreeSVG(summary) {
  const container = document.getElementById('expression-tree-canvas');
  if (!container) return;
  const ast = normalizeAst(parseExpressionToAst(summary.expression || '0'));
  window.currentExpressionAst = ast;
  computeWeights(ast, { mode: 'coef' });
  layoutTree(ast, container.clientWidth || 900, { hGap: 40, vGap: 120 });
  renderSvgTree(container, ast, {
    onContextMenu: (node, point) => showContextMenu(node, point),
    onClick: (node) => highlightNode(node)
  });
}

function applyDeleteSubtree(nodeId) {
  const ast = window.currentExpressionAst;
  // 从 ast 中删除并规范化（见规则）；
  computeWeights(ast, { mode: 'coef' });
  layoutTree(ast, canvasWidth(), metrics);
  renderSvgTree(canvasEl(), ast, handlers);
  const expr = astToExpression(ast);
  // 刷新右上公式
  displayExpressionTreeSummary({ ...lastSummary, expression: expr });
}
```

---

## 十、验收标准（MVP）

- 切换到“符号表达式树”页，树能正确反映表达式结构；
- 节点颜色与权重方向一致：正绿、负红、0 白；
- 右键可删除叶子/子树，树与右上公式同步更新；
- 悬浮能看到变量中文名、权重与子表达式；
- 大于一屏宽/高时可滚动查看（或自动缩放到容器）；
- 无额外前端依赖，Electron 正常运行。

---

## 十一、测试计划

手动测试（优先）：
1. 启动：`scripts/start-dev.sh`（同时拉起后端与 Electron 前端）。
2. 进入“符号表达式树”页，确认右上公式、左侧指标加载完成；
3. 观察树的形状、着色和标签；
4. 对变量叶子/常数执行右键删除与删除子树，验证：
   - 树重绘；
   - 右上公式同步变化并由 MathJax 渲染；
   - 撤销可恢复前一步状态；
5. 使用长表达式（≥ 6 个运算层级）观察布局与性能；
6. 对无效表达式/解析失败显示用户友好错误提示（右上角提示）。

自动/半自动检查：
- 给 `parseExpressionToAst`、`astToExpression` 写简单断言用例（在浏览器控制台触发）。

---

## 十二、时间拆解

- D1：解析器 + 规范化（含一元负号、系数下沉、扁平化）。
- D2：权重计算 V1 + 颜色映射；
- D3：布局算法 + SVG 渲染（含连线）；
- D4：右键菜单与删除逻辑、撤销、联动刷新；
- D5：样式与细节打磨、边界/错误处理；
- D6：验收与文档补充；
- D7（可选）：权重 V2（数值微分）、折叠/展开、导出 SVG/PNG。

---

## 十三、后续增强 Backlog

- 权重计算更准确（数值微分/灵敏度分析）；
- 交互增强：拖拽、缩放、节点折叠/展开；
- 导入/导出 AST 与 SVG；
- 节点批量操作与替换（如把某叶子替换为另一个变量）；
- 节点备注/标星；
- 国际化标签（中英切换、符号中文展示）。

---

## 参考
- 当前页面容器与入口：`frontend/index.html#expression-tree-canvas`，`renderExpressionTreePage()`。
- 变量中文映射：`frontend/data/component_names.js`。
- 公式渲染：MathJax（已集成于 `assets/libs/mathjax.js`）。

